!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AcceptStep	optimization.cc	/^bool OptimizeLbfgs<Real>::AcceptStep(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
Add	kaldi-matrix.cc	/^void MatrixBase<Real>::Add(const Real alpha) {$/;"	f	class:kaldi::MatrixBase
Add	kaldi-vector.cc	/^void VectorBase<Real>::Add(Real c) {$/;"	f	class:kaldi::VectorBase
AddColSumMat	kaldi-vector.cc	/^void VectorBase<Real>::AddColSumMat(Real alpha, const MatrixBase<Real> &M, Real beta) {$/;"	f	class:kaldi::VectorBase
AddDiagMat2	kaldi-vector.cc	/^void VectorBase<Real>::AddDiagMat2($/;"	f	class:kaldi::VectorBase
AddDiagMatMat	kaldi-vector.cc	/^void VectorBase<Real>::AddDiagMatMat($/;"	f	class:kaldi::VectorBase
AddDiagVecMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddDiagVecMat($/;"	f	class:kaldi::MatrixBase
AddDimInfo	kaldi-tensor.cc	/^struct AddDimInfo {$/;"	s	namespace:kaldi	file:
AddMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMat(const Real alpha, const MatrixBase<Real>& A,$/;"	f	class:kaldi::MatrixBase
AddMat2	sp-matrix.cc	/^void SpMatrix<Real>::AddMat2(const Real alpha, const MatrixBase<Real> &M,$/;"	f	class:kaldi::SpMatrix
AddMat2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddMat2Sp($/;"	f	class:kaldi::SpMatrix
AddMat2Vec	sp-matrix.cc	/^void SpMatrix<Real>::AddMat2Vec(const Real alpha,$/;"	f	class:kaldi::SpMatrix
AddMatMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddMatMatDivMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatMatDivMat(const MatrixBase<Real>& A,$/;"	f	class:kaldi::MatrixBase
AddMatMatMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatMatMat(Real alpha,$/;"	f	class:kaldi::MatrixBase
AddMatSmat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatSmat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddMatSp	kaldi-matrix.h	/^  void AddMatSp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddMatSvec	kaldi-vector.cc	/^void VectorBase<Real>::AddMatSvec(const Real alpha,$/;"	f	class:kaldi::VectorBase
AddMatTp	kaldi-matrix.h	/^  void AddMatTp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddMatVec	kaldi-vector.cc	/^void VectorBase<Real>::AddMatVec(const Real alpha,$/;"	f	class:kaldi::VectorBase
AddOuterProductPlusMinus	matrix-functions.cc	/^void AddOuterProductPlusMinus(Real alpha,$/;"	f	namespace:kaldi
AddPacked	packed-matrix.cc	/^void PackedMatrix<Real>::AddPacked(const Real alpha, const PackedMatrix<Real> &rMa) {$/;"	f	class:kaldi::PackedMatrix
AddRowSumMat	kaldi-vector.cc	/^void VectorBase<Real>::AddRowSumMat(Real alpha, const MatrixBase<Real> &M, Real beta) {$/;"	f	class:kaldi::VectorBase
AddSmat2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddSmat2Sp($/;"	f	class:kaldi::SpMatrix
AddSmatMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddSmatMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddSp	kaldi-matrix.cc	/^void MatrixBase<Real>::AddSp(const Real alpha, const SpMatrix<OtherReal> &S) {$/;"	f	class:kaldi::MatrixBase
AddSp	sp-matrix.h	/^  void AddSp(const Real alpha, const SpMatrix<Real> &Ma) {$/;"	f	class:kaldi::SpMatrix
AddSpMat	kaldi-matrix.h	/^  void AddSpMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddSpMatSp	kaldi-matrix.h	/^  void AddSpMatSp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddSpSp	kaldi-matrix.cc	/^void MatrixBase<Real>::AddSpSp(const Real alpha, const SpMatrix<Real> &A_in,$/;"	f	class:kaldi::MatrixBase
AddSpVec	kaldi-vector.cc	/^void VectorBase<Real>::AddSpVec(const Real alpha,$/;"	f	class:kaldi::VectorBase
AddTensorTensor	kaldi-tensor.cc	/^void Tensor<Real>::AddTensorTensor(BaseFloat alpha,$/;"	f	class:kaldi::Tensor
AddToDiag	kaldi-matrix.cc	/^void MatrixBase<Real>::AddToDiag(const Real alpha) {$/;"	f	class:kaldi::MatrixBase
AddToDiag	packed-matrix.cc	/^void PackedMatrix<Real>::AddToDiag(Real r) {$/;"	f	class:kaldi::PackedMatrix
AddTp	tp-matrix.h	/^  void AddTp(const Real alpha, const TpMatrix<Real> &M) {$/;"	f	class:kaldi::TpMatrix
AddTp2	sp-matrix.cc	/^void SpMatrix<Real>::AddTp2(const Real alpha, const TpMatrix<Real> &T,$/;"	f	class:kaldi::SpMatrix
AddTp2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddTp2Sp(const Real alpha, const TpMatrix<Real> &T,$/;"	f	class:kaldi::SpMatrix
AddTpMat	kaldi-matrix.h	/^  void AddTpMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddTpTp	kaldi-matrix.h	/^  void AddTpTp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddTpVec	kaldi-vector.cc	/^void VectorBase<Real>::AddTpVec(const Real alpha, const TpMatrix<Real> &M,$/;"	f	class:kaldi::VectorBase
AddVec	kaldi-vector.cc	/^void VectorBase<Real>::AddVec(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
AddVec	kaldi-vector.cc	/^void VectorBase<double>::AddVec(const double alpha,$/;"	f	class:kaldi::VectorBase
AddVec	kaldi-vector.cc	/^void VectorBase<float>::AddVec(const float alpha,$/;"	f	class:kaldi::VectorBase
AddVec	sp-matrix.cc	/^void  SpMatrix<Real>::AddVec(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::SpMatrix
AddVec2	kaldi-vector.cc	/^void VectorBase<Real>::AddVec2(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
AddVec2	kaldi-vector.cc	/^void VectorBase<Real>::AddVec2(const Real alpha, const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
AddVec2	sp-matrix.cc	/^void SpMatrix<Real>::AddVec2(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::SpMatrix
AddVec2	sp-matrix.cc	/^void SpMatrix<double>::AddVec2(const double alpha, const VectorBase<double> &v) {$/;"	f	class:kaldi::SpMatrix
AddVec2	sp-matrix.cc	/^void SpMatrix<float>::AddVec2(const float alpha, const VectorBase<float> &v) {$/;"	f	class:kaldi::SpMatrix
AddVec2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddVec2Sp(const Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::SpMatrix
AddVecDivVec	kaldi-vector.cc	/^void VectorBase<Real>::AddVecDivVec(Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::VectorBase
AddVecToCols	kaldi-matrix.cc	/^void MatrixBase<Real>::AddVecToCols(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::MatrixBase
AddVecToRows	kaldi-matrix.cc	/^void MatrixBase<Real>::AddVecToRows(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::MatrixBase
AddVecVec	kaldi-matrix.cc	/^void MatrixBase<Real>::AddVecVec(const Real alpha,$/;"	f	class:kaldi::MatrixBase
AddVecVec	kaldi-matrix.cc	/^void MatrixBase<double>::AddVecVec(const double alpha,$/;"	f	class:kaldi::MatrixBase
AddVecVec	kaldi-matrix.cc	/^void MatrixBase<float>::AddVecVec(const float alpha,$/;"	f	class:kaldi::MatrixBase
AddVecVec	kaldi-vector.cc	/^void VectorBase<Real>::AddVecVec(Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::VectorBase
AddVecVec	sp-matrix.cc	/^void SpMatrix<Real>::AddVecVec(const Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::SpMatrix
AllocateData	compressed-matrix.cc	/^void* CompressedMatrix::AllocateData(int32 num_bytes) {$/;"	f	class:kaldi::CompressedMatrix
ApplyAbs	kaldi-vector.cc	/^void VectorBase<Real>::ApplyAbs() {$/;"	f	class:kaldi::VectorBase
ApplyCeiling	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyCeiling(Real ceiling_val) {$/;"	f	class:kaldi::MatrixBase
ApplyCeiling	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::ApplyCeiling(Real ceil_val) {$/;"	f	class:kaldi::VectorBase
ApplyExp	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyExp() {$/;"	f	class:kaldi::MatrixBase
ApplyExp	kaldi-vector.cc	/^void VectorBase<Real>::ApplyExp() {$/;"	f	class:kaldi::VectorBase
ApplyFloor	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyFloor(Real floor_val) {$/;"	f	class:kaldi::MatrixBase
ApplyFloor	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::ApplyFloor(Real floor_val) {$/;"	f	class:kaldi::VectorBase
ApplyFloor	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::ApplyFloor(const VectorBase<Real> &floor_vec) {$/;"	f	class:kaldi::VectorBase
ApplyFloor	sp-matrix.cc	/^int SpMatrix<Real>::ApplyFloor(Real floor) {$/;"	f	class:kaldi::SpMatrix
ApplyFloor	sp-matrix.cc	/^int SpMatrix<Real>::ApplyFloor(const SpMatrix<Real> &C, Real alpha,$/;"	f	class:kaldi::SpMatrix
ApplyHeaviside	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyHeaviside() {$/;"	f	class:kaldi::MatrixBase
ApplyLog	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyLog() {$/;"	f	class:kaldi::MatrixBase
ApplyLog	kaldi-vector.cc	/^void VectorBase<Real>::ApplyLog() {$/;"	f	class:kaldi::VectorBase
ApplyLogAndCopy	kaldi-vector.cc	/^void VectorBase<Real>::ApplyLogAndCopy(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
ApplyPow	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyPow(Real power) {$/;"	f	class:kaldi::MatrixBase
ApplyPow	kaldi-vector.cc	/^void VectorBase<Real>::ApplyPow(Real power) {$/;"	f	class:kaldi::VectorBase
ApplyPow	kaldi-vector.cc	/^void VectorBase<double>::ApplyPow(double power) { vdPowx(dim_, data_, power, data_); }$/;"	f	class:kaldi::VectorBase
ApplyPow	kaldi-vector.cc	/^void VectorBase<float>::ApplyPow(float power) { vsPowx(dim_, data_, power, data_); }$/;"	f	class:kaldi::VectorBase
ApplyPow	sp-matrix.cc	/^void SpMatrix<Real>::ApplyPow(Real power) {$/;"	f	class:kaldi::SpMatrix
ApplySoftMax	kaldi-matrix.cc	/^Real MatrixBase<Real>::ApplySoftMax() {$/;"	f	class:kaldi::MatrixBase
ApplySoftMax	kaldi-vector.cc	/^Real VectorBase<Real>::ApplySoftMax() {$/;"	f	class:kaldi::VectorBase
ApproxEqual	kaldi-matrix.cc	/^bool MatrixBase<Real>::ApproxEqual(const MatrixBase<Real> &other, float tol) const {$/;"	f	class:kaldi::MatrixBase
ApproxEqual	kaldi-matrix.h	/^bool ApproxEqual(const MatrixBase<Real> &A,$/;"	f	namespace:kaldi
ApproxEqual	kaldi-vector.cc	/^bool VectorBase<Real>::ApproxEqual(const VectorBase<Real> &other, float tol) const {$/;"	f	class:kaldi::VectorBase
ApproxEqual	kaldi-vector.h	/^bool ApproxEqual(const VectorBase<Real> &a,$/;"	f	namespace:kaldi
ApproxEqual	sp-matrix.cc	/^bool SpMatrix<Real>::ApproxEqual(const SpMatrix<Real> &other, float tol) const {$/;"	f	class:kaldi::SpMatrix
ApproxEqual	sp-matrix.h	/^inline bool ApproxEqual(const SpMatrix<Real> &A,$/;"	f	namespace:kaldi
AssertEqual	kaldi-matrix.h	/^inline void AssertEqual(MatrixBase<Real> &A, MatrixBase<Real> &B,$/;"	f	namespace:kaldi
AssertEqual	kaldi-vector.h	/^inline void AssertEqual(VectorBase<Real> &a, VectorBase<Real> &b,$/;"	f	namespace:kaldi
AssertEqual	sp-matrix.h	/^inline void AssertEqual(const SpMatrix<Real> &A,$/;"	f	namespace:kaldi
AssertSameDim	matrix-functions.h	/^inline void AssertSameDim(const MatrixBase<Real1> &mat1, const MatrixBase<Real2> &mat2) {$/;"	f	namespace:kaldi
AttemptComplexPower	kaldi-matrix.cc	/^bool AttemptComplexPower(Real *x_re, Real *x_im, Real power) {$/;"	f	namespace:kaldi
B_	matrix-functions.h	/^  std::vector<Matrix<Real> > B_;  \/\/ B_[0] = exp(P_) - I,$/;"	m	class:kaldi::MatrixExponential
Backprop	matrix-functions.cc	/^void MatrixExponential<Real>::Backprop(const MatrixBase<Real> &hX,$/;"	f	class:kaldi::MatrixExponential
Backprop	matrix-functions.cc	/^void MatrixExponential<Real>::Backprop(const SpMatrix<Real> &hX,$/;"	f	class:kaldi::MatrixExponential
BackpropTaylor	matrix-functions.cc	/^void MatrixExponential<Real>::BackpropTaylor(const MatrixBase<Real> &hB0,$/;"	f	class:kaldi::MatrixExponential
BitReversePermute	srfft.cc	/^void SplitRadixComplexFft<Real>::BitReversePermute(Real *x, MatrixIndexT logm) const {$/;"	f	class:kaldi::SplitRadixComplexFft
CharToFloat	compressed-matrix.cc	/^inline float CompressedMatrix::CharToFloat($/;"	f	class:kaldi::CompressedMatrix
Check	sp-matrix.cc	/^void SolverOptions::Check() const {$/;"	f	class:kaldi::SolverOptions
CheckAndFixDims	kaldi-tensor.cc	/^int32 Tensor<Real>::CheckAndFixDims() {$/;"	f	class:kaldi::Tensor
Cholesky	tp-matrix.cc	/^void TpMatrix<Real>::Cholesky(const SpMatrix<Real> &orig) {$/;"	f	class:kaldi::TpMatrix
CholeskyUnitTestTr	matrix-lib-test.cc	/^template<typename Real> static void CholeskyUnitTestTr() {$/;"	f	namespace:kaldi
Clear	matrix-functions.cc	/^void MatrixExponential<Real>::Clear() {$/;"	f	class:kaldi::MatrixExponential
ColRange	kaldi-matrix.h	/^  inline SubMatrix<Real> ColRange(const MatrixIndexT col_offset,$/;"	f	class:kaldi::MatrixBase
ComplexAddProduct	matrix-functions-inl.h	/^template<typename Real> inline void ComplexAddProduct(const Real &a_re, const Real &a_im,$/;"	f	namespace:kaldi
ComplexFft	matrix-functions.cc	/^template<typename Real> void ComplexFft(VectorBase<Real> *v, bool forward, Vector<Real> *tmp_in) {$/;"	f	namespace:kaldi
ComplexFftRecursive	matrix-functions.cc	/^void ComplexFftRecursive (Real *data, int nffts, int N,$/;"	f	namespace:kaldi
ComplexFt	matrix-functions.cc	/^template<typename Real> void ComplexFt (const VectorBase<Real> &in,$/;"	f	namespace:kaldi
ComplexImExp	matrix-functions-inl.h	/^template<typename Real> inline void ComplexImExp(Real x, Real *a_re, Real *a_im) {$/;"	f	namespace:kaldi
ComplexMul	matrix-functions-inl.h	/^template<typename Real> inline void ComplexMul(const Real &a_re, const Real &a_im,$/;"	f	namespace:kaldi
CompressColumn	compressed-matrix.cc	/^void CompressedMatrix::CompressColumn($/;"	f	class:kaldi::CompressedMatrix
CompressedMatrix	compressed-matrix.cc	/^CompressedMatrix::CompressedMatrix(const CompressedMatrix &mat): data_(NULL) {$/;"	f	class:kaldi::CompressedMatrix
CompressedMatrix	compressed-matrix.h	/^  CompressedMatrix(): data_(NULL) { }$/;"	f	class:kaldi::CompressedMatrix
CompressedMatrix	compressed-matrix.h	/^  CompressedMatrix(const MatrixBase<Real> &mat): data_(NULL) { CopyFromMat(mat); }$/;"	f	class:kaldi::CompressedMatrix
CompressedMatrix	compressed-matrix.h	/^class CompressedMatrix {$/;"	c	namespace:kaldi
ComputationState	optimization.h	/^  enum ComputationState {$/;"	g	class:kaldi::OptimizeLbfgs
Compute	matrix-functions.cc	/^void MatrixExponential<Real>::Compute(const MatrixBase<Real> &M,$/;"	f	class:kaldi::MatrixExponential
Compute	matrix-functions.cc	/^void MatrixExponential<Real>::Compute(const SpMatrix<Real> &M,$/;"	f	class:kaldi::MatrixExponential
Compute	srfft.cc	/^void SplitRadixComplexFft<Real>::Compute(Real *x, bool forward) {$/;"	f	class:kaldi::SplitRadixComplexFft
Compute	srfft.cc	/^void SplitRadixComplexFft<Real>::Compute(Real *xr, Real *xi, bool forward) const {$/;"	f	class:kaldi::SplitRadixComplexFft
Compute	srfft.cc	/^void SplitRadixRealFft<Real>::Compute(Real *data, bool forward) {$/;"	f	class:kaldi::SplitRadixRealFft
ComputeColHeader	compressed-matrix.cc	/^void CompressedMatrix::ComputeColHeader($/;"	f	class:kaldi::CompressedMatrix
ComputeDctMatrix	matrix-functions.cc	/^template<typename Real> void ComputeDctMatrix(Matrix<Real> *M) {$/;"	f	namespace:kaldi
ComputeHifNeeded	optimization.cc	/^void OptimizeLbfgs<Real>::ComputeHifNeeded(const VectorBase<Real> &gradient) {$/;"	f	class:kaldi::OptimizeLbfgs
ComputeN	matrix-functions.cc	/^MatrixIndexT MatrixExponential<Real>::ComputeN(const MatrixBase<Real> &M) {$/;"	f	class:kaldi::MatrixExponential
ComputeNewDirection	optimization.cc	/^void OptimizeLbfgs<Real>::ComputeNewDirection(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
ComputePca	matrix-functions.cc	/^void ComputePca(const MatrixBase<Real> &X,$/;"	f	namespace:kaldi
ComputeRecursive	srfft.cc	/^void SplitRadixComplexFft<Real>::ComputeRecursive(Real *xr, Real *xi, MatrixIndexT logm) const {$/;"	f	class:kaldi::SplitRadixComplexFft
ComputeTables	srfft.cc	/^void SplitRadixComplexFft<Real>::ComputeTables() {$/;"	f	class:kaldi::SplitRadixComplexFft
ComputeTaylor	matrix-functions.cc	/^void MatrixExponential<Real>::ComputeTaylor(const MatrixBase<Real> &P, MatrixBase<Real> *B0) {$/;"	f	class:kaldi::MatrixExponential
Cond	kaldi-matrix.cc	/^Real MatrixBase<Real>::Cond() const {$/;"	f	class:kaldi::MatrixBase
Cond	sp-matrix.h	/^  inline Real Cond() const {$/;"	f	class:kaldi::SpMatrix
ConvMat	kaldi-matrix.cc	/^void MatrixBase<Real>::ConvMat(const MatrixBase<Real> &A, int block_dim_x, $/;"	f	class:kaldi::MatrixBase
CopyColFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyColFromMat(const MatrixBase<OtherReal> &mat, MatrixIndexT col) {$/;"	f	class:kaldi::VectorBase
CopyColFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyColFromVec(const VectorBase<Real> &rv,$/;"	f	class:kaldi::MatrixBase
CopyColToVec	compressed-matrix.cc	/^void CompressedMatrix::CopyColToVec(MatrixIndexT col,$/;"	f	class:kaldi::CompressedMatrix
CopyCols	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyCols(const MatrixBase<Real> &src,$/;"	f	class:kaldi::MatrixBase
CopyColsFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyColsFromMat(const MatrixBase<Real> &mat) {$/;"	f	class:kaldi::VectorBase
CopyColsFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyColsFromVec(const VectorBase<Real> &rv) {$/;"	f	class:kaldi::MatrixBase
CopyDiagFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyDiagFromMat(const MatrixBase<Real> &M) {$/;"	f	class:kaldi::VectorBase
CopyDiagFromPacked	kaldi-vector.cc	/^void VectorBase<Real>::CopyDiagFromPacked(const PackedMatrix<Real> &M) {$/;"	f	class:kaldi::VectorBase
CopyDiagFromSp	kaldi-vector.h	/^  inline void CopyDiagFromSp(const SpMatrix<Real> &M) { CopyDiagFromPacked(M); }$/;"	f	class:kaldi::VectorBase
CopyDiagFromTp	kaldi-vector.h	/^  inline void CopyDiagFromTp(const TpMatrix<Real> &M) { CopyDiagFromPacked(M); }$/;"	f	class:kaldi::VectorBase
CopyDiagFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyDiagFromVec(const VectorBase<Real> &rv) {$/;"	f	class:kaldi::MatrixBase
CopyFromMat	compressed-matrix.cc	/^void CompressedMatrix::CopyFromMat($/;"	f	class:kaldi::CompressedMatrix
CopyFromMat	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromMat(const CompressedMatrix &mat) {$/;"	f	class:kaldi::MatrixBase
CopyFromMat	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromMat(const MatrixBase<OtherReal> & M,$/;"	f	class:kaldi::MatrixBase
CopyFromMat	sp-matrix.cc	/^void SpMatrix<Real>::CopyFromMat(const MatrixBase<Real> &M,$/;"	f	class:kaldi::SpMatrix
CopyFromMat	tp-matrix.cc	/^void TpMatrix<Real>::CopyFromMat(const MatrixBase<Real> &M,$/;"	f	class:kaldi::TpMatrix
CopyFromPacked	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromPacked(const PackedMatrix<OtherReal>& M) {$/;"	f	class:kaldi::VectorBase
CopyFromPacked	packed-matrix.cc	/^void PackedMatrix<Real>::CopyFromPacked(const PackedMatrix<OtherReal> &orig) {$/;"	f	class:kaldi::PackedMatrix
CopyFromPtr	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromPtr(const Real *data, MatrixIndexT sz) {$/;"	f	class:kaldi::VectorBase
CopyFromSp	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromSp(const SpMatrix<OtherReal> & M) {$/;"	f	class:kaldi::MatrixBase
CopyFromSp	kaldi-matrix.cc	/^void MatrixBase<double>::CopyFromSp(const SpMatrix<double> & M) {$/;"	f	class:kaldi::MatrixBase
CopyFromSp	kaldi-matrix.cc	/^void MatrixBase<float>::CopyFromSp(const SpMatrix<float> & M) {$/;"	f	class:kaldi::MatrixBase
CopyFromSp	sp-matrix.h	/^  void CopyFromSp(const SpMatrix<OtherReal> &other) {$/;"	f	class:kaldi::SpMatrix
CopyFromSp	sp-matrix.h	/^  void CopyFromSp(const SpMatrix<Real> &other) {$/;"	f	class:kaldi::SpMatrix
CopyFromTp	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromTp(const TpMatrix<OtherReal> & M,$/;"	f	class:kaldi::MatrixBase
CopyFromTp	tp-matrix.h	/^  template<typename OtherReal> void CopyFromTp(const TpMatrix<OtherReal> &other) {$/;"	f	class:kaldi::TpMatrix
CopyFromTp	tp-matrix.h	/^  void CopyFromTp(const TpMatrix<Real> &other) {$/;"	f	class:kaldi::TpMatrix
CopyFromVec	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromVec(const VectorBase<OtherReal> &other) {$/;"	f	class:kaldi::VectorBase
CopyFromVec	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromVec(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
CopyFromVec	packed-matrix.cc	/^void PackedMatrix<Real>::CopyFromVec(const SubVector<OtherReal> &vec) {$/;"	f	class:kaldi::PackedMatrix
CopyLowerToUpper	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyLowerToUpper() {$/;"	f	class:kaldi::MatrixBase
CopyRowFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowFromMat(const MatrixBase<OtherReal> &mat, MatrixIndexT row) {$/;"	f	class:kaldi::VectorBase
CopyRowFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowFromMat(const MatrixBase<Real> &mat, MatrixIndexT row) {$/;"	f	class:kaldi::VectorBase
CopyRowFromSp	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowFromSp(const SpMatrix<OtherReal> &sp, MatrixIndexT row) {$/;"	f	class:kaldi::VectorBase
CopyRowFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRowFromVec(const VectorBase<Real> &rv, const MatrixIndexT row) {$/;"	f	class:kaldi::MatrixBase
CopyRowToVec	compressed-matrix.cc	/^void CompressedMatrix::CopyRowToVec(MatrixIndexT row,$/;"	f	class:kaldi::CompressedMatrix
CopyRows	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRows(const MatrixBase<Real> &src,$/;"	f	class:kaldi::MatrixBase
CopyRowsFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowsFromMat(const MatrixBase<OtherReal> &mat) {$/;"	f	class:kaldi::VectorBase
CopyRowsFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowsFromMat(const MatrixBase<Real> &mat) {$/;"	f	class:kaldi::VectorBase
CopyRowsFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRowsFromVec(const VectorBase<OtherReal> &rv) {$/;"	f	class:kaldi::MatrixBase
CopyRowsFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRowsFromVec(const VectorBase<Real> &rv) {$/;"	f	class:kaldi::MatrixBase
CopyToMat	compressed-matrix.cc	/^void CompressedMatrix::CopyToMat(MatrixBase<Real> *mat) const {$/;"	f	class:kaldi::CompressedMatrix
CopyToMat	compressed-matrix.cc	/^void CompressedMatrix::CopyToMat(int32 row_offset,$/;"	f	class:kaldi::CompressedMatrix
CopyUpperToLower	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyUpperToLower() {$/;"	f	class:kaldi::MatrixBase
CreateEigenvalueMatrix	kaldi-matrix.cc	/^void CreateEigenvalueMatrix(const VectorBase<Real> &re, const VectorBase<Real> &im,$/;"	f	namespace:kaldi
DEBUG_COMPRESSED_MATRIX	compressed-matrix.cc	274;"	d	file:
Data	kaldi-matrix.h	/^  inline Real* Data() { return data_; }$/;"	f	class:kaldi::MatrixBase
Data	kaldi-matrix.h	/^  inline const Real* Data() const {$/;"	f	class:kaldi::MatrixBase
Data	kaldi-tensor.h	/^  Real *Data() { return data_; }$/;"	f	class:kaldi::Tensor
Data	kaldi-vector.h	/^  inline Real* Data() { return data_; }$/;"	f	class:kaldi::VectorBase
Data	kaldi-vector.h	/^  inline const Real* Data() const { return data_; }$/;"	f	class:kaldi::VectorBase
Data	packed-matrix.h	/^  Real* Data() { return data_; }$/;"	f	class:kaldi::PackedMatrix
Data	packed-matrix.h	/^  const Real* Data() const { return data_; }$/;"	f	class:kaldi::PackedMatrix
DataSize	compressed-matrix.h	/^  static MatrixIndexT DataSize(const GlobalHeader &header) {$/;"	f	class:kaldi::CompressedMatrix
Data_workaround	kaldi-matrix.h	/^  inline Real*  Data_workaround() const {$/;"	f	class:kaldi::MatrixBase
Debias	kaldi-gpsr.cc	/^double Debias(const GpsrConfig &opts, const SpMatrix<double> &H,$/;"	f	namespace:kaldi
Destroy	compressed-matrix.cc	/^void CompressedMatrix::Destroy() {$/;"	f	class:kaldi::CompressedMatrix
Destroy	kaldi-matrix.cc	/^void Matrix<Real>::Destroy() {$/;"	f	class:kaldi::Matrix
Destroy	kaldi-vector.cc	/^void Vector<Real>::Destroy() {$/;"	f	class:kaldi::Vector
Destroy	packed-matrix.cc	/^void PackedMatrix<Real>::Destroy() {$/;"	f	class:kaldi::PackedMatrix
DestructiveSvd	kaldi-matrix.cc	/^void MatrixBase<Real>::DestructiveSvd(VectorBase<Real> *s, MatrixBase<Real> *U, MatrixBase<Real> *Vt) {$/;"	f	class:kaldi::MatrixBase
Determinant	tp-matrix.cc	/^Real TpMatrix<Real>::Determinant() {$/;"	f	class:kaldi::TpMatrix
DiffSigmoid	kaldi-matrix.cc	/^void MatrixBase<Real>::DiffSigmoid(const MatrixBase<Real> &value,$/;"	f	class:kaldi::MatrixBase
DiffTanh	kaldi-matrix.cc	/^void MatrixBase<Real>::DiffTanh(const MatrixBase<Real> &value,$/;"	f	class:kaldi::MatrixBase
Dim	kaldi-tensor.cc	/^int32 Tensor<Real>::Dim(int32 index) const {$/;"	f	class:kaldi::Tensor
Dim	kaldi-vector.h	/^  inline MatrixIndexT Dim() const { return dim_; }$/;"	f	class:kaldi::VectorBase
Dim	optimization.h	/^  inline MatrixIndexT Dim() { return x_.Dim(); }$/;"	f	class:kaldi::OptimizeLbfgs
DimInfo	kaldi-tensor.h	/^  struct DimInfo {$/;"	s	class:kaldi::Tensor
DivElements	kaldi-matrix.cc	/^void MatrixBase<Real>::DivElements(const MatrixBase<Real> &a) {$/;"	f	class:kaldi::MatrixBase
DivElements	kaldi-vector.cc	/^void VectorBase<Real>::DivElements(const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
DivElements	kaldi-vector.cc	/^void VectorBase<Real>::DivElements(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
DoStep	optimization.cc	/^void OptimizeLbfgs<Real>::DoStep(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
DoubleFactorial	matrix-lib-test.cc	/^static int32 DoubleFactorial(int32 i) {$/;"	f	namespace:kaldi
Eig	kaldi-matrix.cc	/^void MatrixBase<Real>::Eig(MatrixBase<Real> *P,$/;"	f	class:kaldi::MatrixBase
Eig	qr.cc	/^void SpMatrix<Real>::Eig(VectorBase<Real> *s, MatrixBase<Real> *P) const {$/;"	f	class:kaldi::SpMatrix
EigenvalueDecomposition	jama-eig.h	/^EigenvalueDecomposition<Real>::EigenvalueDecomposition(const MatrixBase<Real> &A) {$/;"	f	class:kaldi::EigenvalueDecomposition
EigenvalueDecomposition	jama-eig.h	/^template<typename Real> class EigenvalueDecomposition {$/;"	c	namespace:kaldi
Equal	kaldi-matrix.cc	/^bool MatrixBase<Real>::Equal(const MatrixBase<Real> &other) const {$/;"	f	class:kaldi::MatrixBase
Exp	sp-matrix.cc	/^void SpMatrix<Real>::Exp() {$/;"	f	class:kaldi::SpMatrix
FloatToChar	compressed-matrix.cc	/^inline unsigned char CompressedMatrix::FloatToChar($/;"	f	class:kaldi::CompressedMatrix
FloatToUint16	compressed-matrix.cc	/^inline uint16 CompressedMatrix::FloatToUint16($/;"	f	class:kaldi::CompressedMatrix
FrobeniusNorm	kaldi-matrix.cc	/^Real MatrixBase<Real>::FrobeniusNorm() const{$/;"	f	class:kaldi::MatrixBase
FrobeniusNorm	sp-matrix.cc	/^Real SpMatrix<Real>::FrobeniusNorm() const {$/;"	f	class:kaldi::SpMatrix
GetImagEigenvalues	jama-eig.h	/^  void GetImagEigenvalues(VectorBase<Real> *i_out) {$/;"	f	class:kaldi::EigenvalueDecomposition
GetProposedValue	optimization.h	/^  const VectorBase<Real>& GetProposedValue() const { return new_x_; }$/;"	f	class:kaldi::OptimizeLbfgs
GetRealEigenvalues	jama-eig.h	/^  void GetRealEigenvalues(VectorBase<Real> *r_out) {$/;"	f	class:kaldi::EigenvalueDecomposition
GetV	jama-eig.h	/^  void GetV(MatrixBase<Real> *V_out) {  \/\/ V is what we call P externally; it's the matrix of$/;"	f	class:kaldi::EigenvalueDecomposition
GetValue	optimization.cc	/^OptimizeLbfgs<Real>::GetValue(Real *objf_value) const {$/;"	f	class:kaldi::OptimizeLbfgs
Givens	qr.cc	/^inline void Givens(Real a, Real b, Real *c, Real *s) {$/;"	f	namespace:kaldi
GlobalHeader	compressed-matrix.h	/^  struct GlobalHeader {$/;"	s	class:kaldi::CompressedMatrix
Gpsr	kaldi-gpsr.h	/^Real Gpsr(const GpsrConfig &opts, const SpMatrix<Real> &H,$/;"	f	namespace:kaldi
GpsrBB	kaldi-gpsr.cc	/^double GpsrBB(const GpsrConfig &opts, const SpMatrix<double> &H,$/;"	f	namespace:kaldi
GpsrBB	kaldi-gpsr.cc	/^float GpsrBB(const GpsrConfig &opts, const SpMatrix<float> &H,$/;"	f	namespace:kaldi
GpsrBasic	kaldi-gpsr.cc	/^double GpsrBasic(const GpsrConfig &opts, const SpMatrix<double> &H,$/;"	f	namespace:kaldi
GpsrBasic	kaldi-gpsr.cc	/^float GpsrBasic(const GpsrConfig &opts, const SpMatrix<float> &H,$/;"	f	namespace:kaldi
GpsrBasicAlpha	kaldi-gpsr.cc	/^double GpsrBasicAlpha(const SpMatrix<double> &H, const Vector<double> &u,$/;"	f	namespace:kaldi
GpsrCalcLinearCoeff	kaldi-gpsr.cc	/^void GpsrCalcLinearCoeff(double tau, const Vector<double> &g,$/;"	f	namespace:kaldi
GpsrConfig	kaldi-gpsr.h	/^  GpsrConfig() {$/;"	f	struct:kaldi::GpsrConfig
GpsrConfig	kaldi-gpsr.h	/^struct GpsrConfig {$/;"	s	namespace:kaldi
GpsrGradient	kaldi-gpsr.cc	/^void GpsrGradient(const SpMatrix<double> &H, const Vector<double> &c,$/;"	f	namespace:kaldi
GpsrObjective	kaldi-gpsr.cc	/^double GpsrObjective(const SpMatrix<double> &H, const Vector<double> &c,$/;"	f	namespace:kaldi
GroupPnorm	kaldi-matrix.cc	/^void MatrixBase<Real>::GroupPnorm(const MatrixBase<Real> &src, Real power) {$/;"	f	class:kaldi::MatrixBase
GroupPnormDeriv	kaldi-matrix.cc	/^void MatrixBase<Real>::GroupPnormDeriv(const MatrixBase<Real> &src1,$/;"	f	class:kaldi::MatrixBase
H	jama-eig.h	/^  inline Real &H(int r, int c) { return H_[r*n_ + c]; }$/;"	f	class:kaldi::EigenvalueDecomposition
H_	jama-eig.h	/^  Real *H_;  \/\/ the nonsymmetric Hessenberg form.$/;"	m	class:kaldi::EigenvalueDecomposition
H_	optimization.h	/^  Vector<Real> H_; \/\/ Current inverse-Hessian estimate.  May be computed by this class itself,$/;"	m	class:kaldi::OptimizeLbfgs
H_was_set_	optimization.h	/^  bool H_was_set_; \/\/ True if the user specified H_; if false,$/;"	m	class:kaldi::OptimizeLbfgs
House	qr.cc	/^void House(MatrixIndexT dim, const Real *x, Real *v, Real *beta) {$/;"	f	namespace:kaldi
HouseBackward	qr.cc	/^void HouseBackward(MatrixIndexT dim, const Real *x, Real *v, Real *beta) {$/;"	f	namespace:kaldi
Hqr2	jama-eig.h	/^template<typename Real> void  EigenvalueDecomposition<Real>::Hqr2() {$/;"	f	class:kaldi::EigenvalueDecomposition
HtkHeader	kaldi-matrix.h	/^struct HtkHeader {$/;"	s	namespace:kaldi
I	kaldi-blas.h	96;"	d
Index	kaldi-matrix.h	/^  Real &Index (MatrixIndexT r, MatrixIndexT c) {  return (*this)(r, c); }$/;"	f	class:kaldi::MatrixBase
Init	kaldi-matrix.cc	/^inline void Matrix<Real>::Init(const MatrixIndexT rows,$/;"	f	class:kaldi::Matrix
Init	kaldi-vector.cc	/^inline void Vector<Real>::Init(const MatrixIndexT dim) {$/;"	f	class:kaldi::Vector
Init	packed-matrix.cc	/^inline void PackedMatrix<Real>::Init(MatrixIndexT r) {$/;"	f	class:kaldi::PackedMatrix
InitRand	kaldi-gpsr-test.cc	/^template<typename Real> static void InitRand(MatrixBase<Real> *M) {$/;"	f	namespace:kaldi
InitRand	kaldi-gpsr-test.cc	/^template<typename Real> static void InitRand(SpMatrix<Real> *M) {$/;"	f	namespace:kaldi
InitRand	kaldi-gpsr-test.cc	/^template<typename Real> static void InitRand(VectorBase<Real> *v) {$/;"	f	namespace:kaldi
InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(MatrixBase<Real> *M) {$/;"	f	namespace:kaldi
InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(SpMatrix<Real> *M) {$/;"	f	namespace:kaldi
InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(TpMatrix<Real> *M) {$/;"	f	namespace:kaldi
InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(Vector<Real> *v) {$/;"	f	namespace:kaldi
InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(VectorBase<Real> *v) {$/;"	f	namespace:kaldi
Integer	srfft.h	/^  typedef MatrixIndexT Integer;$/;"	t	class:kaldi::SplitRadixComplexFft
Invert	kaldi-matrix.cc	/^void MatrixBase<Real>::Invert(Real *log_det, Real *det_sign,$/;"	f	class:kaldi::MatrixBase
Invert	sp-matrix.cc	/^void SpMatrix<Real>::Invert(Real *logdet, Real *det_sign, bool need_inverse) {$/;"	f	class:kaldi::SpMatrix
Invert	tp-matrix.cc	/^void TpMatrix<Real>::Invert() {$/;"	f	class:kaldi::TpMatrix
InvertDouble	kaldi-matrix.cc	/^void MatrixBase<Real>::InvertDouble(Real *log_det, Real *det_sign,$/;"	f	class:kaldi::MatrixBase
InvertDouble	sp-matrix.cc	/^void SpMatrix<Real>::InvertDouble(Real *logdet, Real *det_sign,$/;"	f	class:kaldi::SpMatrix
InvertDouble	tp-matrix.h	/^  void InvertDouble() {$/;"	f	class:kaldi::TpMatrix
InvertElements	kaldi-matrix.cc	/^void MatrixBase<Real>::InvertElements() {$/;"	f	class:kaldi::MatrixBase
InvertElements	kaldi-vector.cc	/^void VectorBase<Real>::InvertElements() {$/;"	f	class:kaldi::VectorBase
IsDiagonal	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsDiagonal(Real cutoff) const{$/;"	f	class:kaldi::MatrixBase
IsDiagonal	sp-matrix.cc	/^bool SpMatrix<Real>::IsDiagonal(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
IsPosDef	sp-matrix.cc	/^bool SpMatrix<Real>::IsPosDef() const {$/;"	f	class:kaldi::SpMatrix
IsSymmetric	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsSymmetric(Real cutoff) const {$/;"	f	class:kaldi::MatrixBase
IsTridiagonal	sp-matrix.cc	/^bool SpMatrix<Real>::IsTridiagonal(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
IsUnit	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsUnit(Real cutoff) const {$/;"	f	class:kaldi::MatrixBase
IsUnit	sp-matrix.cc	/^bool SpMatrix<Real>::IsUnit(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
IsZero	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsZero(Real cutoff)const {$/;"	f	class:kaldi::MatrixBase
IsZero	kaldi-vector.cc	/^bool VectorBase<Real>::IsZero(Real cutoff) const {$/;"	f	class:kaldi::VectorBase
IsZero	sp-matrix.cc	/^bool SpMatrix<Real>::IsZero(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
JamaSvd	jama-svd.h	/^bool MatrixBase<Real>::JamaSvd(VectorBase<Real> *s_in,$/;"	f	class:kaldi::MatrixBase
K	sp-matrix.h	/^  BaseFloat K; \/\/ maximum condition number$/;"	m	struct:kaldi::SolverOptions
KALDI_COMPLEXFFT_BLOCKSIZE	matrix-functions.cc	77;"	d	file:
KALDI_MATRIX_CBLAS_WRAPPERS_H_	cblas-wrappers.h	21;"	d
KALDI_MATRIX_COMPRESSED_MATRIX_H_	compressed-matrix.h	22;"	d
KALDI_MATRIX_JAMA_EIG_H_	jama-eig.h	30;"	d
KALDI_MATRIX_JAMA_SVD_H_	jama-svd.h	29;"	d
KALDI_MATRIX_KALDI_BLAS_H_	kaldi-blas.h	20;"	d
KALDI_MATRIX_KALDI_GPSR_H_	kaldi-gpsr.h	21;"	d
KALDI_MATRIX_KALDI_MATRIX_H_	kaldi-matrix.h	23;"	d
KALDI_MATRIX_KALDI_MATRIX_INL_H_	kaldi-matrix-inl.h	21;"	d
KALDI_MATRIX_KALDI_TENSOR_H_	kaldi-tensor.h	21;"	d
KALDI_MATRIX_KALDI_TENSOR_INL_H_	kaldi-tensor-inl.h	21;"	d
KALDI_MATRIX_KALDI_VECTOR_H_	kaldi-vector.h	24;"	d
KALDI_MATRIX_KALDI_VECTOR_INL_H_	kaldi-vector-inl.h	25;"	d
KALDI_MATRIX_MATRIX_COMMON_H_	matrix-common.h	20;"	d
KALDI_MATRIX_MATRIX_FUNCTIONS_H_	matrix-functions.h	27;"	d
KALDI_MATRIX_MATRIX_FUNCTIONS_INL_H_	matrix-functions-inl.h	26;"	d
KALDI_MATRIX_MATRIX_LIB_H_	matrix-lib.h	23;"	d
KALDI_MATRIX_OPTIMIZATION_H_	optimization.h	26;"	d
KALDI_MATRIX_PACKED_MATRIX_H_	packed-matrix.h	23;"	d
KALDI_MATRIX_SP_MATRIX_H_	sp-matrix.h	22;"	d
KALDI_MATRIX_SP_MATRIX_INL_H_	sp-matrix-inl.h	21;"	d
KALDI_MATRIX_SRFFT_H_	srfft.h	27;"	d
KALDI_MATRIX_TP_MATRIX_H_	tp-matrix.h	23;"	d
KaldiBlasInt	kaldi-blas.h	/^typedef MKL_INT KaldiBlasInt;$/;"	t
KaldiBlasInt	kaldi-blas.h	/^typedef int KaldiBlasInt; \/\/ try int.$/;"	t
KaldiBlasInt	kaldi-blas.h	/^typedef integer KaldiBlasInt;$/;"	t
LapackGesvd	kaldi-matrix.cc	/^void MatrixBase<Real>::LapackGesvd(VectorBase<Real> *s, MatrixBase<Real> *U_in, $/;"	f	class:kaldi::MatrixBase
LargestAbsElem	kaldi-matrix.cc	/^Real MatrixBase<Real>::LargestAbsElem() const{$/;"	f	class:kaldi::MatrixBase
LbfgsOptions	optimization.h	/^  LbfgsOptions (bool minimize = true):$/;"	f	struct:kaldi::LbfgsOptions
LbfgsOptions	optimization.h	/^struct LbfgsOptions {$/;"	s	namespace:kaldi
LimitCond	sp-matrix.cc	/^MatrixIndexT SpMatrix<Real>::LimitCond(Real maxCond, bool invert) {  \/\/ e.g. maxCond = 1.0e+05.$/;"	f	class:kaldi::SpMatrix
LimitCondDouble	sp-matrix.h	/^  MatrixIndexT LimitCondDouble(Real maxCond = 1.0e+5, bool invert = false) {$/;"	f	class:kaldi::SpMatrix
Log	sp-matrix.cc	/^void SpMatrix<Real>::Log() {$/;"	f	class:kaldi::SpMatrix
LogDet	kaldi-matrix.cc	/^Real MatrixBase<Real>::LogDet(Real *det_sign) const {$/;"	f	class:kaldi::MatrixBase
LogDet	sp-matrix.cc	/^Real SpMatrix<Real>::LogDet(Real *det_sign) const {$/;"	f	class:kaldi::SpMatrix
LogPosDefDet	sp-matrix.cc	/^Real SpMatrix<Real>::LogPosDefDet() const {$/;"	f	class:kaldi::SpMatrix
LogSumExp	kaldi-matrix.cc	/^Real MatrixBase<Real>::LogSumExp(Real prune) const {$/;"	f	class:kaldi::MatrixBase
LogSumExp	kaldi-vector.cc	/^Real VectorBase<Real>::LogSumExp(Real prune) const {$/;"	f	class:kaldi::VectorBase
M	optimization.h	/^  inline MatrixIndexT M() { return opts_.m; }$/;"	f	class:kaldi::OptimizeLbfgs
Matrix	kaldi-matrix-inl.h	/^Matrix<Real>::Matrix(): MatrixBase<Real>(NULL, 0, 0, 0) { }$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix (const Matrix<Real> & M):$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix (const MatrixBase<Real> & M,$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix(const CompressedMatrix &M): MatrixBase<Real>() {$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix(const MatrixBase<OtherReal> & M,$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.h	/^  Matrix(const MatrixIndexT r, const MatrixIndexT c,$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.h	/^  explicit Matrix(const SpMatrix<OtherReal> & M) : MatrixBase<Real>() {$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.h	/^  explicit Matrix(const TpMatrix<OtherReal> & M,$/;"	f	class:kaldi::Matrix
Matrix	kaldi-matrix.h	/^class Matrix : public MatrixBase<Real> {$/;"	c	namespace:kaldi
MatrixBase	kaldi-matrix.h	/^  explicit MatrixBase(): data_(NULL) {$/;"	f	class:kaldi::MatrixBase
MatrixBase	kaldi-matrix.h	/^  explicit MatrixBase(Real *data, MatrixIndexT cols, MatrixIndexT rows, MatrixIndexT stride) :$/;"	f	class:kaldi::MatrixBase
MatrixBase	kaldi-matrix.h	/^class MatrixBase {$/;"	c	namespace:kaldi
MatrixExponential	matrix-functions.h	/^  MatrixExponential() { }$/;"	f	class:kaldi::MatrixExponential
MatrixExponential	matrix-functions.h	/^class MatrixExponential {$/;"	c	namespace:kaldi
MatrixIndexT	matrix-common.h	/^typedef int32 MatrixIndexT;$/;"	t	namespace:kaldi
MatrixResizeType	matrix-common.h	/^} MatrixResizeType;$/;"	t	namespace:kaldi	typeref:enum:kaldi::__anon2
MatrixTransposeType	matrix-common.h	/^} MatrixTransposeType;$/;"	t	namespace:kaldi	typeref:enum:kaldi::__anon1
MatrixUnitTest	matrix-lib-test.cc	/^template<typename Real> static void MatrixUnitTest(bool full_test) {$/;"	f	namespace:kaldi
Max	kaldi-matrix.cc	/^Real MatrixBase<Real>::Max() const {$/;"	f	class:kaldi::MatrixBase
Max	kaldi-matrix.cc	/^template<typename Real> void MatrixBase<Real>::Max(const MatrixBase<Real> &A) {$/;"	f	class:kaldi::MatrixBase
Max	kaldi-vector.cc	/^Real VectorBase<Real>::Max() const {$/;"	f	class:kaldi::VectorBase
Max	kaldi-vector.cc	/^Real VectorBase<Real>::Max(MatrixIndexT *index_out) const {$/;"	f	class:kaldi::VectorBase
Max	packed-matrix.h	/^  Real Max() const {$/;"	f	class:kaldi::PackedMatrix
MaxAbsEig	sp-matrix.cc	/^Real SpMatrix<Real>::MaxAbsEig() const {$/;"	f	class:kaldi::SpMatrix
Min	kaldi-matrix.cc	/^Real MatrixBase<Real>::Min() const {$/;"	f	class:kaldi::MatrixBase
Min	kaldi-vector.cc	/^Real VectorBase<Real>::Min() const {$/;"	f	class:kaldi::VectorBase
Min	kaldi-vector.cc	/^Real VectorBase<Real>::Min(MatrixIndexT *index_out) const {$/;"	f	class:kaldi::VectorBase
Min	packed-matrix.h	/^  Real Min() const {$/;"	f	class:kaldi::PackedMatrix
MinSingularValue	kaldi-matrix.h	/^  Real MinSingularValue() const {$/;"	f	class:kaldi::MatrixBase
MulColsVec	kaldi-matrix.cc	/^void MatrixBase<Real>::MulColsVec(const VectorBase<Real> &scale) {$/;"	f	class:kaldi::MatrixBase
MulElements	kaldi-matrix.cc	/^void MatrixBase<Real>::MulElements(const MatrixBase<Real> &a) {$/;"	f	class:kaldi::MatrixBase
MulElements	kaldi-vector.cc	/^void VectorBase<Real>::MulElements(const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
MulElements	kaldi-vector.cc	/^void VectorBase<Real>::MulElements(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
MulRowsGroupMat	kaldi-matrix.cc	/^void MatrixBase<Real>::MulRowsGroupMat(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
MulRowsVec	kaldi-matrix.cc	/^void MatrixBase<Real>::MulRowsVec(const VectorBase<Real> &scale) {$/;"	f	class:kaldi::MatrixBase
MulTp	kaldi-vector.cc	/^void VectorBase<Real>::MulTp(const TpMatrix<Real> &M,$/;"	f	class:kaldi::VectorBase
N_	matrix-functions.h	/^  MatrixIndexT N_;  \/\/ Power N_ >=0 such that P_ = A * 2^(-N_),$/;"	m	class:kaldi::MatrixExponential
N_	srfft.h	/^  Integer N_;$/;"	m	class:kaldi::SplitRadixComplexFft
N_	srfft.h	/^  int N_;$/;"	m	class:kaldi::SplitRadixRealFft
NonDiagonalness	matrix-lib-test.cc	/^static Real NonDiagonalness(const SpMatrix<Real> &S) {$/;"	f	namespace:kaldi
NonOrthogonality	matrix-lib-test.cc	/^static Real NonOrthogonality(const MatrixBase<Real> &M, MatrixTransposeType transM) {$/;"	f	namespace:kaldi
NonUnitness	matrix-lib-test.cc	/^static Real NonUnitness(const SpMatrix<Real> &S) {$/;"	f	namespace:kaldi
Norm	kaldi-vector.cc	/^Real VectorBase<Real>::Norm(Real p) const {$/;"	f	class:kaldi::VectorBase
NumCols	compressed-matrix.h	/^  inline MatrixIndexT NumCols() const { return (data_ == NULL) ? 0 :$/;"	f	class:kaldi::CompressedMatrix
NumCols	kaldi-matrix.h	/^  inline MatrixIndexT NumCols() const { return num_cols_; }$/;"	f	class:kaldi::MatrixBase
NumCols	packed-matrix.h	/^  inline MatrixIndexT NumCols() const { return num_rows_; }$/;"	f	class:kaldi::PackedMatrix
NumRows	compressed-matrix.h	/^  inline MatrixIndexT NumRows() const { return (data_ == NULL) ? 0 :$/;"	f	class:kaldi::CompressedMatrix
NumRows	kaldi-matrix.h	/^  inline MatrixIndexT  NumRows() const { return num_rows_; }$/;"	f	class:kaldi::MatrixBase
NumRows	packed-matrix.h	/^  inline MatrixIndexT NumRows() const { return num_rows_; }$/;"	f	class:kaldi::PackedMatrix
OptimizeLbfgs	optimization.cc	/^OptimizeLbfgs<Real>::OptimizeLbfgs(const VectorBase<Real> &x,$/;"	f	class:kaldi::OptimizeLbfgs
OptimizeLbfgs	optimization.h	/^class OptimizeLbfgs {$/;"	c	namespace:kaldi
Orthes	jama-eig.h	/^void EigenvalueDecomposition<Real>::Orthes() {$/;"	f	class:kaldi::EigenvalueDecomposition
OrthogonalizeRows	kaldi-matrix.cc	/^void MatrixBase<Real>::OrthogonalizeRows() {$/;"	f	class:kaldi::MatrixBase
OtherReal	matrix-common.h	/^template<> class OtherReal<double> {$/;"	c	namespace:kaldi
OtherReal	matrix-common.h	/^template<> class OtherReal<float> {$/;"	c	namespace:kaldi
OtherReal	matrix-common.h	/^template<typename T> class OtherReal { };  \/\/ useful in reading+writing routines$/;"	c	namespace:kaldi
P_	matrix-functions.h	/^  Matrix<Real> P_;  \/\/ Equals M * 2^(-N_)$/;"	m	class:kaldi::MatrixExponential
PackedMatrix	packed-matrix.h	/^  PackedMatrix() : data_(NULL), num_rows_(0) {}$/;"	f	class:kaldi::PackedMatrix
PackedMatrix	packed-matrix.h	/^  explicit PackedMatrix(MatrixIndexT r, MatrixResizeType resize_type = kSetZero):$/;"	f	class:kaldi::PackedMatrix
PackedMatrix	packed-matrix.h	/^  explicit PackedMatrix(const PackedMatrix<OtherReal> &orig) : data_(NULL) {$/;"	f	class:kaldi::PackedMatrix
PackedMatrix	packed-matrix.h	/^  explicit PackedMatrix(const PackedMatrix<Real> &orig) : data_(NULL) {$/;"	f	class:kaldi::PackedMatrix
PackedMatrix	packed-matrix.h	/^template<typename Real> class PackedMatrix {$/;"	c	namespace:kaldi
PerColHeader	compressed-matrix.h	/^  struct PerColHeader {$/;"	s	class:kaldi::CompressedMatrix
Power	kaldi-matrix.cc	/^bool MatrixBase<Real>::Power(Real power) {$/;"	f	class:kaldi::MatrixBase
PrintEigs	sp-matrix.h	/^  void PrintEigs(const char *name) {$/;"	f	class:kaldi::SpMatrix
Qr	qr.cc	/^void SpMatrix<Real>::Qr(MatrixBase<Real> *Q) {$/;"	f	class:kaldi::SpMatrix
QrInternal	qr.cc	/^void QrInternal(MatrixIndexT n,$/;"	f	namespace:kaldi
QrStep	qr.cc	/^void QrStep(MatrixIndexT n,$/;"	f	namespace:kaldi
RandCategorical	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::RandCategorical() const {$/;"	f	class:kaldi::VectorBase
RandPosdefSpMatrix	matrix-lib-test.cc	/^void RandPosdefSpMatrix(MatrixIndexT dim, SpMatrix<Real> *matrix) {$/;"	f	namespace:kaldi
Range	kaldi-matrix.h	/^  inline SubMatrix<Real> Range(const MatrixIndexT row_offset,$/;"	f	class:kaldi::MatrixBase
Range	kaldi-vector.h	/^  SubVector<Real> Range(const MatrixIndexT o, const MatrixIndexT l) {$/;"	f	class:kaldi::VectorBase
Range	kaldi-vector.h	/^  const SubVector<Real> Range(const MatrixIndexT o,$/;"	f	class:kaldi::VectorBase
Read	compressed-matrix.cc	/^void CompressedMatrix::Read(std::istream &is, bool binary) {$/;"	f	class:kaldi::CompressedMatrix
Read	kaldi-matrix.cc	/^void Matrix<Real>::Read(std::istream & is, bool binary, bool add) {$/;"	f	class:kaldi::Matrix
Read	kaldi-matrix.cc	/^void MatrixBase<Real>::Read(std::istream & is, bool binary, bool add) {$/;"	f	class:kaldi::MatrixBase
Read	kaldi-vector.cc	/^void Vector<Real>::Read(std::istream & is,  bool binary, bool add) {$/;"	f	class:kaldi::Vector
Read	kaldi-vector.cc	/^void VectorBase<Real>::Read(std::istream & is,  bool binary, bool add) {$/;"	f	class:kaldi::VectorBase
Read	packed-matrix.cc	/^void PackedMatrix<Real>::Read(std::istream& is, bool binary, bool add) {$/;"	f	class:kaldi::PackedMatrix
ReadHtk	kaldi-matrix.cc	/^bool ReadHtk(std::istream &is, Matrix<Real> *M_ptr, HtkHeader *header_ptr)$/;"	f	namespace:kaldi
Real	matrix-common.h	/^  typedef double Real;$/;"	t	class:kaldi::OtherReal
Real	matrix-common.h	/^  typedef float Real;$/;"	t	class:kaldi::OtherReal
RealFft	matrix-functions.cc	/^template<typename Real> void RealFft (VectorBase<Real> *v, bool forward) {$/;"	f	namespace:kaldi
RealFftInefficient	matrix-functions.cc	/^template<typename Real> void RealFftInefficient (VectorBase<Real> *v, bool forward) {$/;"	f	namespace:kaldi
RecentStepLength	optimization.cc	/^Real OptimizeLbfgs<Real>::RecentStepLength() const {$/;"	f	class:kaldi::OptimizeLbfgs
RecordStepLength	optimization.cc	/^void OptimizeLbfgs<Real>::RecordStepLength(Real s) {$/;"	f	class:kaldi::OptimizeLbfgs
Register	kaldi-gpsr.h	/^inline void GpsrConfig::Register(OptionsItf *po) {$/;"	f	class:kaldi::GpsrConfig
RemoveElement	kaldi-vector.cc	/^void Vector<Real>::RemoveElement(MatrixIndexT i) {$/;"	f	class:kaldi::Vector
RemoveRow	kaldi-matrix.cc	/^void Matrix<Real>::RemoveRow(MatrixIndexT i) {$/;"	f	class:kaldi::Matrix
ReplaceValue	kaldi-vector.cc	/^void VectorBase<Real>::ReplaceValue(Real orig, Real changed) {$/;"	f	class:kaldi::VectorBase
Resize	kaldi-matrix.cc	/^void Matrix<Real>::Resize(const MatrixIndexT rows,$/;"	f	class:kaldi::Matrix
Resize	kaldi-vector.cc	/^void Vector<Real>::Resize(const MatrixIndexT dim, MatrixResizeType resize_type) {$/;"	f	class:kaldi::Vector
Resize	packed-matrix.cc	/^void PackedMatrix<Real>::Resize(MatrixIndexT r, MatrixResizeType resize_type) {$/;"	f	class:kaldi::PackedMatrix
Resize	sp-matrix.h	/^  inline void Resize(MatrixIndexT nRows, MatrixResizeType resize_type = kSetZero) {$/;"	f	class:kaldi::SpMatrix
Resize	tp-matrix.h	/^  void Resize(MatrixIndexT nRows, MatrixResizeType resize_type = kSetZero) {$/;"	f	class:kaldi::TpMatrix
Restart	optimization.cc	/^void OptimizeLbfgs<Real>::Restart(const VectorBase<Real> &x,$/;"	f	class:kaldi::OptimizeLbfgs
Row	kaldi-matrix.h	/^  inline SubVector<Real> Row(MatrixIndexT i) {$/;"	f	class:kaldi::MatrixBase
Row	kaldi-matrix.h	/^  inline const SubVector<Real> Row(MatrixIndexT i) const {$/;"	f	class:kaldi::MatrixBase
RowData	kaldi-matrix.h	/^  inline  Real* RowData(MatrixIndexT i) {$/;"	f	class:kaldi::MatrixBase
RowData	kaldi-matrix.h	/^  inline const Real* RowData(MatrixIndexT i) const {$/;"	f	class:kaldi::MatrixBase
RowRange	kaldi-matrix.h	/^  inline SubMatrix<Real> RowRange(const MatrixIndexT row_offset,$/;"	f	class:kaldi::MatrixBase
S	optimization.h	/^  SubVector<Real> S(MatrixIndexT i) {$/;"	f	class:kaldi::OptimizeLbfgs
SameDim	kaldi-matrix.h	/^bool SameDim(const MatrixBase<Real> &M, const MatrixBase<Real> &N) {$/;"	f	namespace:kaldi
Scale	kaldi-matrix.cc	/^template<typename Real> void MatrixBase<Real>::Scale(Real alpha) {$/;"	f	class:kaldi::MatrixBase
Scale	kaldi-tensor.cc	/^void Tensor<Real>::Scale(BaseFloat alpha) {$/;"	f	class:kaldi::Tensor
Scale	kaldi-vector.cc	/^void VectorBase<Real>::Scale(Real alpha) {$/;"	f	class:kaldi::VectorBase
Scale	packed-matrix.cc	/^void PackedMatrix<Real>::Scale(Real alpha) {$/;"	f	class:kaldi::PackedMatrix
ScaleDiag	packed-matrix.cc	/^void PackedMatrix<Real>::ScaleDiag(Real alpha) {$/;"	f	class:kaldi::PackedMatrix
Set	kaldi-matrix.cc	/^void MatrixBase<Real>::Set(Real value) {$/;"	f	class:kaldi::MatrixBase
Set	kaldi-vector.cc	/^void VectorBase<Real>::Set(Real f) {$/;"	f	class:kaldi::VectorBase
SetDiag	packed-matrix.cc	/^void PackedMatrix<Real>::SetDiag(Real alpha) {$/;"	f	class:kaldi::PackedMatrix
SetRandUniform	kaldi-matrix.cc	/^void MatrixBase<Real>::SetRandUniform() {$/;"	f	class:kaldi::MatrixBase
SetRandn	kaldi-matrix.cc	/^void MatrixBase<Real>::SetRandn() {$/;"	f	class:kaldi::MatrixBase
SetRandn	kaldi-vector.cc	/^void VectorBase<Real>::SetRandn() {$/;"	f	class:kaldi::VectorBase
SetRandn	packed-matrix.cc	/^void PackedMatrix<Real>::SetRandn() {$/;"	f	class:kaldi::PackedMatrix
SetUnit	kaldi-matrix.cc	/^void MatrixBase<Real>::SetUnit() {$/;"	f	class:kaldi::MatrixBase
SetUnit	packed-matrix.cc	/^void PackedMatrix<Real>::SetUnit() {$/;"	f	class:kaldi::PackedMatrix
SetZero	kaldi-matrix.cc	/^void MatrixBase<Real>::SetZero() {$/;"	f	class:kaldi::MatrixBase
SetZero	kaldi-vector.cc	/^void VectorBase<Real>::SetZero() {$/;"	f	class:kaldi::VectorBase
SetZero	packed-matrix.cc	/^void PackedMatrix<Real>::SetZero() {$/;"	f	class:kaldi::PackedMatrix
Sigmoid	kaldi-matrix.cc	/^void MatrixBase<Real>::Sigmoid(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
Sigmoid	kaldi-vector.cc	/^void VectorBase<Real>::Sigmoid(const VectorBase<Real> &src) {$/;"	f	class:kaldi::VectorBase
Sigmoid	kaldi-vector.cc	/^void VectorBase<double>::Sigmoid(const VectorBase<double> &src) {$/;"	f	class:kaldi::VectorBase
Sigmoid	kaldi-vector.cc	/^void VectorBase<float>::Sigmoid(const VectorBase<float> &src) {$/;"	f	class:kaldi::VectorBase
SignedMatrixIndexT	matrix-common.h	/^typedef int32 SignedMatrixIndexT;$/;"	t	namespace:kaldi
SizeInBytes	kaldi-matrix.h	/^  size_t  SizeInBytes() const {$/;"	f	class:kaldi::MatrixBase
SizeInBytes	kaldi-vector.h	/^  inline MatrixIndexT SizeInBytes() const { return (dim_*sizeof(Real)); }$/;"	f	class:kaldi::VectorBase
SizeInBytes	packed-matrix.h	/^  size_t SizeInBytes() const {$/;"	f	class:kaldi::PackedMatrix
SlowMatMul	matrix-lib-test.cc	/^template<typename Real> static void SlowMatMul() {$/;"	f	namespace:kaldi
SoftHinge	kaldi-matrix.cc	/^void MatrixBase<Real>::SoftHinge(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
SolveDoubleQuadraticMatrixProblem	sp-matrix.cc	/^Real SolveDoubleQuadraticMatrixProblem(const MatrixBase<Real> &G,$/;"	f	namespace:kaldi
SolveQuadraticMatrixProblem	sp-matrix.cc	/^SolveQuadraticMatrixProblem(const SpMatrix<Real> &Q,$/;"	f	namespace:kaldi
SolveQuadraticProblem	sp-matrix.cc	/^template<> double SolveQuadraticProblem(const SpMatrix<double> &H,$/;"	f	namespace:kaldi
SolveQuadraticProblem	sp-matrix.cc	/^template<> float SolveQuadraticProblem(const SpMatrix<float> &H,$/;"	f	namespace:kaldi
SolverOptions	sp-matrix.h	/^  SolverOptions(): K(1.0e+4), eps(1.0e-40), name("[unknown]"),$/;"	f	struct:kaldi::SolverOptions
SolverOptions	sp-matrix.h	/^  explicit SolverOptions(const std::string &name):$/;"	f	struct:kaldi::SolverOptions
SolverOptions	sp-matrix.h	/^struct SolverOptions {$/;"	s	namespace:kaldi
SortSvd	kaldi-matrix.cc	/^template<typename Real> void  SortSvd(VectorBase<Real> *s, MatrixBase<Real> *U,$/;"	f	namespace:kaldi
SpCopyType	matrix-common.h	/^} SpCopyType;$/;"	t	namespace:kaldi	typeref:enum:kaldi::__anon3
SpMatrix	sp-matrix.h	/^  SpMatrix(): PackedMatrix<Real>() {}$/;"	f	class:kaldi::SpMatrix
SpMatrix	sp-matrix.h	/^  SpMatrix(const SpMatrix<Real> &orig)$/;"	f	class:kaldi::SpMatrix
SpMatrix	sp-matrix.h	/^  explicit SpMatrix(MatrixIndexT r, MatrixResizeType resize_type = kSetZero)$/;"	f	class:kaldi::SpMatrix
SpMatrix	sp-matrix.h	/^  explicit SpMatrix(const MatrixBase<Real> & orig,$/;"	f	class:kaldi::SpMatrix
SpMatrix	sp-matrix.h	/^  explicit SpMatrix(const SpMatrix<OtherReal> &orig)$/;"	f	class:kaldi::SpMatrix
SpMatrix	sp-matrix.h	/^class SpMatrix : public PackedMatrix<Real> {$/;"	c	namespace:kaldi
SplitRadixComplexFft	srfft.cc	/^SplitRadixComplexFft<Real>::SplitRadixComplexFft(MatrixIndexT N) {$/;"	f	class:kaldi::SplitRadixComplexFft
SplitRadixComplexFft	srfft.h	/^class SplitRadixComplexFft {$/;"	c	namespace:kaldi
SplitRadixRealFft	srfft.h	/^  SplitRadixRealFft(MatrixIndexT N):  \/\/ will fail unless N>=4 and N is a power of 2.$/;"	f	class:kaldi::SplitRadixRealFft
SplitRadixRealFft	srfft.h	/^class SplitRadixRealFft: private SplitRadixComplexFft<Real> {$/;"	c	namespace:kaldi
StepSizeIteration	optimization.cc	/^void OptimizeLbfgs<Real>::StepSizeIteration(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
Stride	kaldi-matrix.h	/^  inline MatrixIndexT Stride() const {  return stride_; }$/;"	f	class:kaldi::MatrixBase
Stride	kaldi-tensor.cc	/^int32 Tensor<Real>::Stride(int32 index) const {$/;"	f	class:kaldi::Tensor
SubMatrix	kaldi-matrix.cc	/^SubMatrix<Real>::SubMatrix(Real *data,$/;"	f	class:kaldi::SubMatrix
SubMatrix	kaldi-matrix.cc	/^SubMatrix<Real>::SubMatrix(const MatrixBase<Real> &M,$/;"	f	class:kaldi::SubMatrix
SubMatrix	kaldi-matrix.h	/^  SubMatrix<Real> (const SubMatrix &other):$/;"	f	class:kaldi::SubMatrix
SubMatrix	kaldi-matrix.h	/^class SubMatrix : public MatrixBase<Real> {$/;"	c	namespace:kaldi
SubVector	kaldi-vector.h	/^  SubVector(Real *data, MatrixIndexT length) : VectorBase<Real> () {$/;"	f	class:kaldi::SubVector
SubVector	kaldi-vector.h	/^  SubVector(const MatrixBase<Real> &matrix, MatrixIndexT row) {$/;"	f	class:kaldi::SubVector
SubVector	kaldi-vector.h	/^  SubVector(const PackedMatrix<Real> &M) {$/;"	f	class:kaldi::SubVector
SubVector	kaldi-vector.h	/^  SubVector(const SubVector &other) : VectorBase<Real> () {$/;"	f	class:kaldi::SubVector
SubVector	kaldi-vector.h	/^  SubVector(const VectorBase<Real> &t, const MatrixIndexT origin,$/;"	f	class:kaldi::SubVector
SubVector	kaldi-vector.h	/^class SubVector : public VectorBase<Real> {$/;"	c	namespace:kaldi
Sum	kaldi-matrix.cc	/^Real MatrixBase<Real>::Sum() const {$/;"	f	class:kaldi::MatrixBase
Sum	kaldi-vector.cc	/^Real VectorBase<Real>::Sum() const {$/;"	f	class:kaldi::VectorBase
SumLog	kaldi-vector.cc	/^Real VectorBase<Real>::SumLog() const {$/;"	f	class:kaldi::VectorBase
Svd	kaldi-matrix.cc	/^void MatrixBase<Real>::Svd(VectorBase<Real> *s, MatrixBase<Real> *U, MatrixBase<Real> *Vt) const {$/;"	f	class:kaldi::MatrixBase
Svd	kaldi-matrix.h	/^  void Svd(VectorBase<Real> *s) const { Svd(s, NULL, NULL); }$/;"	f	class:kaldi::MatrixBase
Swap	compressed-matrix.h	/^  void Swap(CompressedMatrix *other) { std::swap(data_, other->data_); }$/;"	f	class:kaldi::CompressedMatrix
Swap	kaldi-matrix.cc	/^void Matrix<Real>::Swap(Matrix<Real> *other) {$/;"	f	class:kaldi::Matrix
Swap	kaldi-vector.cc	/^void Vector<Real>::Swap(Vector<Real> *other) {$/;"	f	class:kaldi::Vector
Swap	packed-matrix.cc	/^void PackedMatrix<Real>::Swap(Matrix<Real> *other) {$/;"	f	class:kaldi::PackedMatrix
Swap	packed-matrix.cc	/^void PackedMatrix<Real>::Swap(PackedMatrix<Real> *other) {$/;"	f	class:kaldi::PackedMatrix
Swap	sp-matrix.cc	/^void SpMatrix<Real>::Swap(SpMatrix<Real> *other) {$/;"	f	class:kaldi::SpMatrix
Swap	tp-matrix.cc	/^void TpMatrix<Real>::Swap(TpMatrix<Real> *other) {$/;"	f	class:kaldi::TpMatrix
SymAddMat2	kaldi-matrix.cc	/^void MatrixBase<Real>::SymAddMat2(const Real alpha,$/;"	f	class:kaldi::MatrixBase
SymPosSemiDefEig	kaldi-matrix.cc	/^void MatrixBase<Real>::SymPosSemiDefEig(VectorBase<Real> *rs, MatrixBase<Real> *rU, Real check_thresh) \/\/ e.g. check_thresh = 0.001$/;"	f	class:kaldi::MatrixBase
SymPosSemiDefEig	sp-matrix.cc	/^void SpMatrix<Real>::SymPosSemiDefEig(VectorBase<Real> *s,$/;"	f	class:kaldi::SpMatrix
Tanh	kaldi-matrix.cc	/^void MatrixBase<Real>::Tanh(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
Tanh	kaldi-vector.cc	/^void VectorBase<Real>::Tanh(const VectorBase<Real> &src) {$/;"	f	class:kaldi::VectorBase
Tanh	kaldi-vector.cc	/^void VectorBase<double>::Tanh(const VectorBase<double> &src) {$/;"	f	class:kaldi::VectorBase
Tanh	kaldi-vector.cc	/^void VectorBase<float>::Tanh(const VectorBase<float> &src) {$/;"	f	class:kaldi::VectorBase
Tensor	kaldi-tensor.cc	/^Tensor<Real>::Tensor(const MatrixBase<Real> &mat,$/;"	f	class:kaldi::Tensor
Tensor	kaldi-tensor.cc	/^Tensor<Real>::Tensor(const VectorBase<Real> &vec,$/;"	f	class:kaldi::Tensor
Tensor	kaldi-tensor.h	/^  Tensor() { } \/\/ Disallow default constructor.$/;"	f	class:kaldi::Tensor
Tensor	kaldi-tensor.h	/^class Tensor {  $/;"	c	namespace:kaldi
TestUninitialized	kaldi-matrix.cc	/^void MatrixBase<Real>::TestUninitialized() const {$/;"	f	class:kaldi::MatrixBase
TopEigs	qr.cc	/^void SpMatrix<Real>::TopEigs(VectorBase<Real> *s, MatrixBase<Real> *P,$/;"	f	class:kaldi::SpMatrix
TpMatrix	tp-matrix.h	/^  TpMatrix() : PackedMatrix<Real>() {}$/;"	f	class:kaldi::TpMatrix
TpMatrix	tp-matrix.h	/^  TpMatrix(const TpMatrix<Real>& Orig) : PackedMatrix<Real>(Orig) {}$/;"	f	class:kaldi::TpMatrix
TpMatrix	tp-matrix.h	/^  explicit TpMatrix(MatrixIndexT r, MatrixResizeType resize_type = kSetZero)$/;"	f	class:kaldi::TpMatrix
TpMatrix	tp-matrix.h	/^  template<typename OtherReal> explicit TpMatrix(const TpMatrix<OtherReal>& Orig)$/;"	f	class:kaldi::TpMatrix
TpMatrix	tp-matrix.h	/^class TpMatrix : public PackedMatrix<Real> {$/;"	c	namespace:kaldi
Tql2	jama-eig.h	/^template<typename Real> void EigenvalueDecomposition<Real>::Tql2() {$/;"	f	class:kaldi::EigenvalueDecomposition
Trace	kaldi-matrix.cc	/^Real MatrixBase<Real>::Trace(bool check_square) const  {$/;"	f	class:kaldi::MatrixBase
Trace	packed-matrix.cc	/^Real PackedMatrix<Real>::Trace() const {$/;"	f	class:kaldi::PackedMatrix
Trace	sp-matrix.cc	/^Real SpMatrix<Real>::Trace() const {$/;"	f	class:kaldi::SpMatrix
TraceMat	kaldi-matrix.h	/^double TraceMat(const MatrixBase<Real> &A) { return A.Trace(); }$/;"	f	namespace:kaldi
TraceMatMat	kaldi-matrix.cc	/^Real TraceMatMat(const MatrixBase<Real> &A,$/;"	f	namespace:kaldi
TraceMatMatMat	kaldi-matrix.cc	/^Real TraceMatMatMat(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
TraceMatMatMatMat	kaldi-matrix.cc	/^Real TraceMatMatMatMat(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
TraceMatSpMat	sp-matrix.cc	/^Real TraceMatSpMat(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
TraceMatSpMatSp	sp-matrix.cc	/^Real TraceMatSpMatSp(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
TraceSpMat	sp-matrix.cc	/^Real TraceSpMat(const SpMatrix<Real> &A, const MatrixBase<Real> &B) {$/;"	f	namespace:kaldi
TraceSpSp	sp-matrix.cc	/^Real TraceSpSp(const SpMatrix<Real> &A, const SpMatrix<OtherReal> &B) {$/;"	f	namespace:kaldi
TraceSpSp	sp-matrix.cc	/^double TraceSpSp(const SpMatrix<double> &A, const SpMatrix<double> &B) {$/;"	f	namespace:kaldi
TraceSpSp	sp-matrix.cc	/^float TraceSpSp(const SpMatrix<float> &A, const SpMatrix<float> &B) {$/;"	f	namespace:kaldi
TraceSpSpLower	sp-matrix.cc	/^Real TraceSpSpLower(const SpMatrix<Real> &A, const SpMatrix<Real> &B) {$/;"	f	namespace:kaldi
Transpose	kaldi-matrix.cc	/^void Matrix<Real>::Transpose() {$/;"	f	class:kaldi::Matrix
Transpose	kaldi-matrix.cc	/^void MatrixBase<Real>::Transpose() {$/;"	f	class:kaldi::MatrixBase
Tred2	jama-eig.h	/^template<typename Real> void  EigenvalueDecomposition<Real>::Tred2() {$/;"	f	class:kaldi::EigenvalueDecomposition
Tridiagonalize	qr.cc	/^void SpMatrix<Real>::Tridiagonalize(MatrixBase<Real> *Q) {$/;"	f	class:kaldi::SpMatrix
Uint16ToFloat	compressed-matrix.cc	/^inline float CompressedMatrix::Uint16ToFloat($/;"	f	class:kaldi::CompressedMatrix
UnitTestAddDiagMat2	matrix-lib-test.cc	/^static void UnitTestAddDiagMat2() {$/;"	f	namespace:kaldi
UnitTestAddDiagMatMat	matrix-lib-test.cc	/^static void UnitTestAddDiagMatMat() {$/;"	f	namespace:kaldi
UnitTestAddDiagVecMat	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddDiagVecMat() {$/;"	f	namespace:kaldi
UnitTestAddMat2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMat2() {$/;"	f	namespace:kaldi
UnitTestAddMat2Sp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMat2Sp() {$/;"	f	namespace:kaldi
UnitTestAddMatSelf	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMatSelf() {$/;"	f	namespace:kaldi
UnitTestAddMatSmat	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMatSmat() {$/;"	f	namespace:kaldi
UnitTestAddOuterProductPlusMinus	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddOuterProductPlusMinus() {$/;"	f	namespace:kaldi
UnitTestAddSp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddSp() {$/;"	f	namespace:kaldi
UnitTestAddToDiag	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddToDiag() {$/;"	f	namespace:kaldi
UnitTestAddToDiagMatrix	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddToDiagMatrix() {$/;"	f	namespace:kaldi
UnitTestAddVec2Sp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVec2Sp() {$/;"	f	namespace:kaldi
UnitTestAddVecCross	matrix-lib-test.cc	/^void UnitTestAddVecCross() {$/;"	f	namespace:kaldi
UnitTestAddVecToCols	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVecToCols() {$/;"	f	namespace:kaldi
UnitTestAddVecToRows	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVecToRows() {$/;"	f	namespace:kaldi
UnitTestAddVecVec	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVecVec() {$/;"	f	namespace:kaldi
UnitTestAxpy	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAxpy() {$/;"	f	namespace:kaldi
UnitTestComplexFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestComplexFft() {$/;"	f	namespace:kaldi
UnitTestComplexFft2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestComplexFft2() {$/;"	f	namespace:kaldi
UnitTestComplexFt	matrix-lib-test.cc	/^template<typename Real> static void UnitTestComplexFt() {$/;"	f	namespace:kaldi
UnitTestComplexPower	matrix-lib-test.cc	/^void UnitTestComplexPower() {$/;"	f	namespace:kaldi
UnitTestCompressedMatrix	matrix-lib-test.cc	/^template<typename Real> static void UnitTestCompressedMatrix() {$/;"	f	namespace:kaldi
UnitTestCopyCols	matrix-lib-test.cc	/^static void UnitTestCopyCols() {$/;"	f	namespace:kaldi
UnitTestCopyRows	matrix-lib-test.cc	/^static void UnitTestCopyRows() {$/;"	f	namespace:kaldi
UnitTestCopyRowsAndCols	matrix-lib-test.cc	/^template<typename Real> static void UnitTestCopyRowsAndCols() {$/;"	f	namespace:kaldi
UnitTestCopySp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestCopySp() {$/;"	f	namespace:kaldi
UnitTestDct	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDct() {$/;"	f	namespace:kaldi
UnitTestDeterminant	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDeterminant() {  \/\/ also tests matrix axpy and IsZero() and TraceOfProduct{, T}$/;"	f	namespace:kaldi
UnitTestDeterminantSign	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDeterminantSign() {$/;"	f	namespace:kaldi
UnitTestDotprod	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDotprod() {$/;"	f	namespace:kaldi
UnitTestEig	matrix-lib-test.cc	/^template<typename Real> static void UnitTestEig() {$/;"	f	namespace:kaldi
UnitTestEigSp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestEigSp() {$/;"	f	namespace:kaldi
UnitTestEigSymmetric	matrix-lib-test.cc	/^template<typename Real> static void UnitTestEigSymmetric() {$/;"	f	namespace:kaldi
UnitTestFloorCeiling	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestFloorCeiling() {$/;"	f	namespace:kaldi
UnitTestFloorChol	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestFloorChol() {$/;"	f	namespace:kaldi
UnitTestFloorUnit	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestFloorUnit() {$/;"	f	namespace:kaldi
UnitTestGpsr	kaldi-gpsr-test.cc	/^template<typename Real> static void UnitTestGpsr() {$/;"	f	namespace:kaldi
UnitTestHeaviside	matrix-lib-test.cc	/^template<typename Real> static void UnitTestHeaviside() {$/;"	f	namespace:kaldi
UnitTestHtkIo	matrix-lib-test.cc	/^template<typename Real> static void UnitTestHtkIo() {$/;"	f	namespace:kaldi
UnitTestInnerProd	matrix-lib-test.cc	/^template<typename Real> static void UnitTestInnerProd() {$/;"	f	namespace:kaldi
UnitTestInverse	matrix-lib-test.cc	/^template<typename Real> static void UnitTestInverse() {$/;"	f	namespace:kaldi
UnitTestIo	matrix-lib-test.cc	/^template<typename Real> static void UnitTestIo() {$/;"	f	namespace:kaldi
UnitTestIoCross	matrix-lib-test.cc	/^template<typename Real> static void UnitTestIoCross() {  \/\/ across types.$/;"	f	namespace:kaldi
UnitTestLbfgs	matrix-lib-test.cc	/^template<typename Real> static void UnitTestLbfgs() {$/;"	f	namespace:kaldi
UnitTestLimitCond	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestLimitCond() {$/;"	f	namespace:kaldi
UnitTestLimitCondInvert	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestLimitCondInvert() {$/;"	f	namespace:kaldi
UnitTestMat2Vec	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestMat2Vec() {$/;"	f	namespace:kaldi
UnitTestMatrixExponential	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMatrixExponential() {$/;"	f	namespace:kaldi
UnitTestMatrixExponentialBackprop	matrix-lib-test.cc	/^static void UnitTestMatrixExponentialBackprop() {$/;"	f	namespace:kaldi
UnitTestMax2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMax2() {$/;"	f	namespace:kaldi
UnitTestMaxAbsEig	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMaxAbsEig() {$/;"	f	namespace:kaldi
UnitTestMaxMin	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMaxMin() {$/;"	f	namespace:kaldi
UnitTestMmul	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMmul() {$/;"	f	namespace:kaldi
UnitTestMmulSym	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMmulSym() {$/;"	f	namespace:kaldi
UnitTestMul	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMul() {$/;"	f	namespace:kaldi
UnitTestMulElements	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMulElements() {$/;"	f	namespace:kaldi
UnitTestNonsymmetricPower	matrix-lib-test.cc	/^void UnitTestNonsymmetricPower() {$/;"	f	namespace:kaldi
UnitTestNorm	matrix-lib-test.cc	/^static void UnitTestNorm() {  \/\/ test some simple norm properties: scaling.  also ApproxEqual test.$/;"	f	namespace:kaldi
UnitTestOrthogonalizeRows	matrix-lib-test.cc	/^static void UnitTestOrthogonalizeRows() {$/;"	f	namespace:kaldi
UnitTestPca	matrix-lib-test.cc	/^static void UnitTestPca(bool full_test) {$/;"	f	namespace:kaldi
UnitTestPca2	matrix-lib-test.cc	/^static void UnitTestPca2(bool full_test) {$/;"	f	namespace:kaldi
UnitTestPower	matrix-lib-test.cc	/^template<typename Real> static void UnitTestPower() {$/;"	f	namespace:kaldi
UnitTestRandCategorical	matrix-lib-test.cc	/^static void UnitTestRandCategorical() {$/;"	f	namespace:kaldi
UnitTestRange	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRange() {  \/\/ Testing SubMatrix class.$/;"	f	namespace:kaldi
UnitTestRankNUpdate	matrix-lib-test.cc	/^static void UnitTestRankNUpdate() {$/;"	f	namespace:kaldi
UnitTestRealFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRealFft() {$/;"	f	namespace:kaldi
UnitTestRealFftSpeed	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRealFftSpeed() {$/;"	f	namespace:kaldi
UnitTestRemoveRow	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRemoveRow() {$/;"	f	namespace:kaldi
UnitTestReplaceValue	matrix-lib-test.cc	/^static void UnitTestReplaceValue(){$/;"	f	namespace:kaldi
UnitTestResize	matrix-lib-test.cc	/^static void UnitTestResize() {$/;"	f	namespace:kaldi
UnitTestRow	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRow() {$/;"	f	namespace:kaldi
UnitTestScale	matrix-lib-test.cc	/^template<typename Real> static void UnitTestScale() {$/;"	f	namespace:kaldi
UnitTestScaleDiag	matrix-lib-test.cc	/^template<typename Real> static void UnitTestScaleDiag() {$/;"	f	namespace:kaldi
UnitTestSetDiag	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSetDiag() {$/;"	f	namespace:kaldi
UnitTestSetRandUniform	matrix-lib-test.cc	/^static void UnitTestSetRandUniform() {$/;"	f	namespace:kaldi
UnitTestSetRandn	matrix-lib-test.cc	/^static void UnitTestSetRandn() {$/;"	f	namespace:kaldi
UnitTestSger	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSger() {$/;"	f	namespace:kaldi
UnitTestSherman	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSherman() {$/;"	f	namespace:kaldi
UnitTestSigmoid	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSigmoid() {$/;"	f	namespace:kaldi
UnitTestSimple	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSimple() {$/;"	f	namespace:kaldi
UnitTestSimpleForMat	matrix-lib-test.cc	/^static void UnitTestSimpleForMat() {  \/\/ test some simple operates on all kinds of matrix$/;"	f	namespace:kaldi
UnitTestSimpleForVec	matrix-lib-test.cc	/^static void UnitTestSimpleForVec() {  \/\/ testing some simple operaters on vector$/;"	f	namespace:kaldi
UnitTestSoftHinge	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSoftHinge() {$/;"	f	namespace:kaldi
UnitTestSolve	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSolve() {$/;"	f	namespace:kaldi
UnitTestSpAddVec	matrix-lib-test.cc	/^static void UnitTestSpAddVec() {$/;"	f	namespace:kaldi
UnitTestSpAddVecVec	matrix-lib-test.cc	/^static void UnitTestSpAddVecVec() {$/;"	f	namespace:kaldi
UnitTestSpInvert	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSpInvert() {$/;"	f	namespace:kaldi
UnitTestSpLogExp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSpLogExp() {$/;"	f	namespace:kaldi
UnitTestSpVec	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSpVec() {$/;"	f	namespace:kaldi
UnitTestSpliceRows	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSpliceRows() {$/;"	f	namespace:kaldi
UnitTestSplitRadixComplexFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixComplexFft() {$/;"	f	namespace:kaldi
UnitTestSplitRadixComplexFft2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixComplexFft2() {$/;"	f	namespace:kaldi
UnitTestSplitRadixRealFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixRealFft() {$/;"	f	namespace:kaldi
UnitTestSplitRadixRealFftSpeed	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixRealFftSpeed() {$/;"	f	namespace:kaldi
UnitTestSubvector	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSubvector() {$/;"	f	namespace:kaldi
UnitTestSvd	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvd() {$/;"	f	namespace:kaldi
UnitTestSvdBad	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdBad() {$/;"	f	namespace:kaldi
UnitTestSvdJustvec	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdJustvec() {  \/\/ Making sure gives same answer if we get just the vector, not the eigs.$/;"	f	namespace:kaldi
UnitTestSvdNodestroy	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdNodestroy() {$/;"	f	namespace:kaldi
UnitTestSvdSpeed	matrix-lib-test.cc	/^static void UnitTestSvdSpeed() {$/;"	f	namespace:kaldi
UnitTestSvdZero	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdZero() {$/;"	f	namespace:kaldi
UnitTestSymAddMat2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSymAddMat2() {$/;"	f	namespace:kaldi
UnitTestTanh	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestTanh() {$/;"	f	namespace:kaldi
UnitTestTopEigs	matrix-lib-test.cc	/^static void UnitTestTopEigs() {$/;"	f	namespace:kaldi
UnitTestTp2	matrix-lib-test.cc	/^static void UnitTestTp2() {$/;"	f	namespace:kaldi
UnitTestTp2Sp	matrix-lib-test.cc	/^static void UnitTestTp2Sp() {$/;"	f	namespace:kaldi
UnitTestTpInvert	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestTpInvert() {$/;"	f	namespace:kaldi
UnitTestTrace	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTrace() {$/;"	f	namespace:kaldi
UnitTestTraceProduct	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTraceProduct() {$/;"	f	namespace:kaldi
UnitTestTraceSpSpLower	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTraceSpSpLower() {$/;"	f	namespace:kaldi
UnitTestTranspose	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTranspose() {$/;"	f	namespace:kaldi
UnitTestTransposeScatter	matrix-lib-test.cc	/^static void UnitTestTransposeScatter() {$/;"	f	namespace:kaldi
UnitTestTridiag	matrix-lib-test.cc	/^static void UnitTestTridiag() {$/;"	f	namespace:kaldi
UnitTestTridiagonalize	matrix-lib-test.cc	/^static void UnitTestTridiagonalize() {$/;"	f	namespace:kaldi
UnitTestTridiagonalizeAndQr	matrix-lib-test.cc	/^static void UnitTestTridiagonalizeAndQr() {$/;"	f	namespace:kaldi
UnitTestVecmul	matrix-lib-test.cc	/^template<typename Real> static void UnitTestVecmul() {$/;"	f	namespace:kaldi
UnitTestVectorMax	matrix-lib-test.cc	/^static void UnitTestVectorMax() {$/;"	f	namespace:kaldi
UnitTestVectorMin	matrix-lib-test.cc	/^static void UnitTestVectorMin() {$/;"	f	namespace:kaldi
UnsignedMatrixIndexT	matrix-common.h	/^typedef uint32 UnsignedMatrixIndexT;$/;"	t	namespace:kaldi
V	jama-eig.h	/^  inline Real &V(int r, int c) { return V_[r*n_ + c]; }$/;"	f	class:kaldi::EigenvalueDecomposition
V_	jama-eig.h	/^  Real *V_;  \/\/ the eigenvectors (P in our external notation)$/;"	m	class:kaldi::EigenvalueDecomposition
VecMatVec	kaldi-vector.cc	/^Real VecMatVec(const VectorBase<Real> &v1, const MatrixBase<Real> &M,$/;"	f	namespace:kaldi
VecSpVec	sp-matrix.cc	/^Real VecSpVec(const VectorBase<Real> &v1, const SpMatrix<Real> &M,$/;"	f	namespace:kaldi
VecVec	kaldi-vector.cc	/^Real VecVec(const VectorBase<Real> &a,$/;"	f	namespace:kaldi
VecVec	kaldi-vector.cc	/^Real VecVec(const VectorBase<Real> &ra,$/;"	f	namespace:kaldi
Vector	kaldi-vector.h	/^  Vector(): VectorBase<Real>() {}$/;"	f	class:kaldi::Vector
Vector	kaldi-vector.h	/^  Vector(const Vector<Real> &v) : VectorBase<Real>()  { \/\/  (cannot be explicit)$/;"	f	class:kaldi::Vector
Vector	kaldi-vector.h	/^  explicit Vector(const MatrixIndexT s,$/;"	f	class:kaldi::Vector
Vector	kaldi-vector.h	/^  explicit Vector(const VectorBase<OtherReal> &v): VectorBase<Real>() {$/;"	f	class:kaldi::Vector
Vector	kaldi-vector.h	/^  explicit Vector(const VectorBase<Real> &v) : VectorBase<Real>() {$/;"	f	class:kaldi::Vector
Vector	kaldi-vector.h	/^class Vector: public VectorBase<Real> {$/;"	c	namespace:kaldi
VectorBase	kaldi-vector.h	/^  explicit VectorBase(): data_(NULL), dim_(0) {$/;"	f	class:kaldi::VectorBase
VectorBase	kaldi-vector.h	/^class VectorBase {$/;"	c	namespace:kaldi
Write	compressed-matrix.cc	/^void CompressedMatrix::Write(std::ostream &os, bool binary) const {$/;"	f	class:kaldi::CompressedMatrix
Write	kaldi-matrix.cc	/^void MatrixBase<Real>::Write(std::ostream &os, bool binary) const {$/;"	f	class:kaldi::MatrixBase
Write	kaldi-vector.cc	/^void VectorBase<Real>::Write(std::ostream & os, bool binary) const {$/;"	f	class:kaldi::VectorBase
Write	packed-matrix.cc	/^void PackedMatrix<Real>::Write(std::ostream &os, bool binary) const {$/;"	f	class:kaldi::PackedMatrix
WriteHtk	kaldi-matrix.cc	/^bool WriteHtk(std::ostream &os, const MatrixBase<Real> &M, HtkHeader htk_hdr) \/\/ header may be derived from a previous call to ReadHtk.  Must be in binary mode.$/;"	f	namespace:kaldi
WriteSphinx	kaldi-matrix.cc	/^bool WriteSphinx(std::ostream &os, const MatrixBase<Real> &M)$/;"	f	namespace:kaldi
Xgemv_sparsevec	cblas-wrappers.h	/^inline void Xgemv_sparsevec(MatrixTransposeType trans, MatrixIndexT num_rows,$/;"	f	namespace:kaldi
Y	optimization.h	/^  SubVector<Real> Y(MatrixIndexT i) {$/;"	f	class:kaldi::OptimizeLbfgs
abs	kaldi-blas.h	75;"	d
abs	kaldi-blas.h	99;"	d
alpha_max	kaldi-gpsr.h	/^  double alpha_max;  \/\/\/< Maximum step size in the feasible direction$/;"	m	struct:kaldi::GpsrConfig
alpha_min	kaldi-gpsr.h	/^  double alpha_min;  \/\/\/< Minimum step size in the feasible direction$/;"	m	struct:kaldi::GpsrConfig
approx_equal	matrix-lib-test.cc	/^static bool approx_equal(Real a, Real b) {$/;"	f	namespace:kaldi
avg_step_length	optimization.h	/^  int avg_step_length; \/\/ number of iters to avg step length over, in$/;"	m	struct:kaldi::LbfgsOptions
best_f_	optimization.h	/^  Real best_f_; \/\/ the best objective function so far.$/;"	m	class:kaldi::OptimizeLbfgs
best_x_	optimization.h	/^  Vector<Real> best_x_; \/\/ the x with the best objective function so far$/;"	m	class:kaldi::OptimizeLbfgs
bit_clear	kaldi-blas.h	106;"	d
bit_clear	kaldi-blas.h	82;"	d
bit_set	kaldi-blas.h	107;"	d
bit_set	kaldi-blas.h	83;"	d
bit_test	kaldi-blas.h	105;"	d
bit_test	kaldi-blas.h	81;"	d
brseed	srfft.h	/^  Integer *brseed;$/;"	m	class:kaldi::SplitRadixComplexFft
c1	optimization.h	/^  float c1; \/\/ A constant in Armijo rule = Wolfe condition i)$/;"	m	struct:kaldi::LbfgsOptions
c2	optimization.h	/^  float c2; \/\/ A constant in Wolfe condition ii)$/;"	m	struct:kaldi::LbfgsOptions
cblas_Xasum	cblas-wrappers.h	/^inline double cblas_Xasum(const int N, const double *X, const int incX) {$/;"	f	namespace:kaldi
cblas_Xasum	cblas-wrappers.h	/^inline float cblas_Xasum(const int N, const float *X, const int incX) {$/;"	f	namespace:kaldi
cblas_Xaxpy	cblas-wrappers.h	/^inline void cblas_Xaxpy(const int N, const double alpha, const double *X,$/;"	f	namespace:kaldi
cblas_Xaxpy	cblas-wrappers.h	/^inline void cblas_Xaxpy(const int N, const float alpha, const float *X,$/;"	f	namespace:kaldi
cblas_Xcopy	cblas-wrappers.h	/^inline void cblas_Xcopy(const int N, const double *X, const int incX, double *Y,$/;"	f	namespace:kaldi
cblas_Xcopy	cblas-wrappers.h	/^inline void cblas_Xcopy(const int N, const float *X, const int incX, float *Y,$/;"	f	namespace:kaldi
cblas_Xdot	cblas-wrappers.h	/^inline double cblas_Xdot(const int N, const double *const X,$/;"	f	namespace:kaldi
cblas_Xdot	cblas-wrappers.h	/^inline float cblas_Xdot(const int N, const float *const X,$/;"	f	namespace:kaldi
cblas_Xgbmv	cblas-wrappers.h	/^inline void cblas_Xgbmv(MatrixTransposeType trans, MatrixIndexT num_rows,$/;"	f	namespace:kaldi
cblas_Xgemm	cblas-wrappers.h	/^inline void cblas_Xgemm(const double alpha,$/;"	f	namespace:kaldi
cblas_Xgemm	cblas-wrappers.h	/^inline void cblas_Xgemm(const float alpha,$/;"	f	namespace:kaldi
cblas_Xgemv	cblas-wrappers.h	/^inline void cblas_Xgemv(MatrixTransposeType trans, MatrixIndexT num_rows,$/;"	f	namespace:kaldi
cblas_Xger	cblas-wrappers.h	/^inline void cblas_Xger(MatrixIndexT num_rows, MatrixIndexT num_cols, double alpha,$/;"	f	namespace:kaldi
cblas_Xger	cblas-wrappers.h	/^inline void cblas_Xger(MatrixIndexT num_rows, MatrixIndexT num_cols, float alpha,$/;"	f	namespace:kaldi
cblas_Xrot	cblas-wrappers.h	/^inline void cblas_Xrot(const int N, double *X, const int incX, double *Y,$/;"	f	namespace:kaldi
cblas_Xrot	cblas-wrappers.h	/^inline void cblas_Xrot(const int N, float *X, const int incX, float *Y,$/;"	f	namespace:kaldi
cblas_Xsbmv1	cblas-wrappers.h	/^inline void cblas_Xsbmv1($/;"	f	namespace:kaldi
cblas_Xscal	cblas-wrappers.h	/^inline void cblas_Xscal(const int N, const double alpha, double *data, $/;"	f	namespace:kaldi
cblas_Xscal	cblas-wrappers.h	/^inline void cblas_Xscal(const int N, const float alpha, float *data,$/;"	f	namespace:kaldi
cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(MatrixIndexT dim, double alpha, const double *Mdata,$/;"	f	namespace:kaldi
cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(MatrixIndexT dim, float alpha, const float *Mdata,$/;"	f	namespace:kaldi
cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(const double alpha, const int num_rows, const double *Mdata,$/;"	f	namespace:kaldi
cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(const float alpha, const int num_rows, const float *Mdata,$/;"	f	namespace:kaldi
cblas_Xspr	cblas-wrappers.h	/^inline void cblas_Xspr(MatrixIndexT dim, double alpha, const double *Xdata,$/;"	f	namespace:kaldi
cblas_Xspr	cblas-wrappers.h	/^inline void cblas_Xspr(MatrixIndexT dim, float alpha, const float *Xdata,$/;"	f	namespace:kaldi
cblas_Xspr2	cblas-wrappers.h	/^inline void cblas_Xspr2(MatrixIndexT dim, double alpha, const double *Xdata,$/;"	f	namespace:kaldi
cblas_Xspr2	cblas-wrappers.h	/^inline void cblas_Xspr2(MatrixIndexT dim, float alpha, const float *Xdata,$/;"	f	namespace:kaldi
cblas_Xsymm	cblas-wrappers.h	/^inline void cblas_Xsymm(const double alpha,$/;"	f	namespace:kaldi
cblas_Xsymm	cblas-wrappers.h	/^inline void cblas_Xsymm(const float alpha,$/;"	f	namespace:kaldi
cblas_Xsyrk	cblas-wrappers.h	/^inline void cblas_Xsyrk ($/;"	f	namespace:kaldi
cblas_Xsyrk	cblas-wrappers.h	/^inline void cblas_Xsyrk($/;"	f	namespace:kaldi
cblas_Xtpmv	cblas-wrappers.h	/^inline void cblas_Xtpmv(MatrixTransposeType trans, const double *Mdata,$/;"	f	namespace:kaldi
cblas_Xtpmv	cblas-wrappers.h	/^inline void cblas_Xtpmv(MatrixTransposeType trans, const float *Mdata,$/;"	f	namespace:kaldi
cdiv	jama-eig.h	/^  inline static void cdiv(Real xr, Real xi, Real yr, Real yi, Real *cdivr, Real *cdivi) {$/;"	f	class:kaldi::EigenvalueDecomposition
clapack_Xgesvd	cblas-wrappers.h	/^inline void clapack_Xgesvd(char *v, char *u, KaldiBlasInt *num_cols,$/;"	f	namespace:kaldi
clapack_Xgetrf	cblas-wrappers.h	/^inline void clapack_Xgetrf(MatrixIndexT num_rows, MatrixIndexT num_cols,$/;"	f	namespace:kaldi
clapack_Xgetrf2	cblas-wrappers.h	/^inline void clapack_Xgetrf2(KaldiBlasInt *num_rows, KaldiBlasInt *num_cols, $/;"	f	namespace:kaldi
clapack_Xgetri	cblas-wrappers.h	/^inline void clapack_Xgetri(MatrixIndexT num_rows, double *Mdata, MatrixIndexT stride,$/;"	f	namespace:kaldi
clapack_Xgetri	cblas-wrappers.h	/^inline void clapack_Xgetri(MatrixIndexT num_rows, float *Mdata, MatrixIndexT stride,$/;"	f	namespace:kaldi
clapack_Xgetri2	cblas-wrappers.h	/^inline void clapack_Xgetri2(KaldiBlasInt *num_rows, double *Mdata, KaldiBlasInt *stride,$/;"	f	namespace:kaldi
clapack_Xgetri2	cblas-wrappers.h	/^inline void clapack_Xgetri2(KaldiBlasInt *num_rows, float *Mdata, KaldiBlasInt *stride,$/;"	f	namespace:kaldi
clapack_Xsptrf	cblas-wrappers.h	/^void inline clapack_Xsptrf(KaldiBlasInt *num_rows, double *Mdata,$/;"	f	namespace:kaldi
clapack_Xsptrf	cblas-wrappers.h	/^void inline clapack_Xsptrf(KaldiBlasInt *num_rows, float *Mdata,$/;"	f	namespace:kaldi
clapack_Xsptri	cblas-wrappers.h	/^void inline clapack_Xsptri(KaldiBlasInt *num_rows, double *Mdata, $/;"	f	namespace:kaldi
clapack_Xsptri	cblas-wrappers.h	/^void inline clapack_Xsptri(KaldiBlasInt *num_rows, float *Mdata, $/;"	f	namespace:kaldi
clapack_Xtptri	cblas-wrappers.h	/^inline void clapack_Xtptri(KaldiBlasInt *num_rows, double *Mdata, KaldiBlasInt *result) {$/;"	f	namespace:kaldi
clapack_Xtptri	cblas-wrappers.h	/^inline void clapack_Xtptri(KaldiBlasInt *num_rows, float *Mdata, KaldiBlasInt *result) {$/;"	f	namespace:kaldi
clapack_Xtrtri	cblas-wrappers.h	/^inline int clapack_Xtrtri(int num_rows, double *Mdata, MatrixIndexT stride) {$/;"	f	namespace:kaldi
clapack_Xtrtri	cblas-wrappers.h	/^inline int clapack_Xtrtri(int num_rows, float *Mdata, MatrixIndexT stride) {$/;"	f	namespace:kaldi
complex	kaldi-blas.h	/^    typedef __CLPK_complex          complex;$/;"	t
complex	kaldi-blas.h	97;"	d
computation_state_	optimization.h	/^  ComputationState computation_state_;$/;"	m	class:kaldi::OptimizeLbfgs
d	optimization.h	/^  float d; \/\/ An amount > 1.0 (default 2.0) that we initially multiply or$/;"	m	struct:kaldi::LbfgsOptions
d_	jama-eig.h	/^  Real *d_, *e_;  \/\/ real and imaginary parts of eigenvalues.$/;"	m	class:kaldi::EigenvalueDecomposition
d_	optimization.h	/^  Real d_; \/\/ a number d > 1.0, but during an iteration we may decrease this, when$/;"	m	class:kaldi::OptimizeLbfgs
dabs	kaldi-blas.h	100;"	d
dabs	kaldi-blas.h	76;"	d
data_	compressed-matrix.h	/^  void *data_; \/\/ first GlobalHeader, then PerColHeader (repeated), then$/;"	m	class:kaldi::CompressedMatrix
data_	kaldi-matrix.h	/^  Real*   data_;$/;"	m	class:kaldi::MatrixBase
data_	kaldi-tensor.h	/^  Real *data_;  \/\/ not owned here.$/;"	m	class:kaldi::Tensor
data_	kaldi-vector.h	/^  Real* data_;$/;"	m	class:kaldi::VectorBase
data_	optimization.h	/^  Matrix<Real> data_; \/\/ dimension (m*2) x dim.  Even rows store$/;"	m	class:kaldi::OptimizeLbfgs
data_	packed-matrix.h	/^  Real *data_;$/;"	m	class:kaldi::PackedMatrix
debias	kaldi-gpsr.h	/^  bool debias;  \/\/\/< Do debiasing, i.e. unconstrained optimization at the end$/;"	m	struct:kaldi::GpsrConfig
deriv_	optimization.h	/^  Vector<Real> deriv_; \/\/ The most recently evaluated derivative-- at x_k.$/;"	m	class:kaldi::OptimizeLbfgs
diagonal_precondition	sp-matrix.h	/^  bool diagonal_precondition;$/;"	m	struct:kaldi::SolverOptions
dim	kaldi-tensor.cc	/^  int32 dim; \/\/ dim we count up to.$/;"	m	struct:kaldi::AddDimInfo	file:
dim	kaldi-tensor.h	/^    int32 dim;$/;"	m	struct:kaldi::Tensor::DimInfo
dim_	kaldi-vector.h	/^  MatrixIndexT dim_;$/;"	m	class:kaldi::VectorBase
dims_	kaldi-tensor.h	/^  DimInfo dims_[5];$/;"	m	class:kaldi::Tensor
dmax	kaldi-blas.h	104;"	d
dmax	kaldi-blas.h	80;"	d
dmin	kaldi-blas.h	103;"	d
dmin	kaldi-blas.h	79;"	d
doublecomplex	kaldi-blas.h	/^    typedef __CLPK_doublecomplex    doublecomplex;$/;"	t
doublereal	kaldi-blas.h	/^    typedef __CLPK_doublereal       doublereal;$/;"	t
e_	jama-eig.h	/^  Real *d_, *e_;  \/\/ real and imaginary parts of eigenvalues.$/;"	m	class:kaldi::EigenvalueDecomposition
eps	sp-matrix.h	/^  BaseFloat eps; $/;"	m	struct:kaldi::SolverOptions
f_	optimization.h	/^  Real f_; \/\/ The function evaluated at x_k.$/;"	m	class:kaldi::OptimizeLbfgs
first_step_impr	optimization.h	/^  float first_step_impr; \/\/ If this variable is >0.0, it overrides$/;"	m	struct:kaldi::LbfgsOptions
first_step_learning_rate	optimization.h	/^  float first_step_learning_rate; \/\/ The very first step of L-BFGS is$/;"	m	struct:kaldi::LbfgsOptions
first_step_length	optimization.h	/^  float first_step_length; \/\/ If this variable is >0.0, it overrides$/;"	m	struct:kaldi::LbfgsOptions
ftnlen	kaldi-blas.h	/^    typedef __CLPK_ftnlen           ftnlen;$/;"	t
gpsr_beta	kaldi-gpsr.h	/^  double gpsr_beta;$/;"	m	struct:kaldi::GpsrConfig
gpsr_mu	kaldi-gpsr.h	/^  double gpsr_mu;$/;"	m	struct:kaldi::GpsrConfig
gpsr_tau	kaldi-gpsr.h	/^  double gpsr_tau;  \/\/\/< Regularization scale$/;"	m	struct:kaldi::GpsrConfig
integer	kaldi-blas.h	/^    typedef __CLPK_integer          integer;$/;"	t
kBeforeStep	optimization.h	/^    kBeforeStep,$/;"	e	enum:kaldi::OptimizeLbfgs::ComputationState
kCopyData	matrix-common.h	/^  kCopyData$/;"	e	enum:kaldi::__anon2
kNoTrans	matrix-common.h	/^  kNoTrans = CblasNoTrans$/;"	e	enum:kaldi::__anon1
kNone	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	e	enum:kaldi::OptimizeLbfgs::__anon4
kSetZero	matrix-common.h	/^  kSetZero,$/;"	e	enum:kaldi::__anon2
kTakeLower	matrix-common.h	/^  kTakeLower,$/;"	e	enum:kaldi::__anon3
kTakeMean	matrix-common.h	/^  kTakeMean,$/;"	e	enum:kaldi::__anon3
kTakeMeanAndCheck	matrix-common.h	/^  kTakeMeanAndCheck$/;"	e	enum:kaldi::__anon3
kTakeUpper	matrix-common.h	/^  kTakeUpper,$/;"	e	enum:kaldi::__anon3
kTrans	matrix-common.h	/^  kTrans    = CblasTrans,$/;"	e	enum:kaldi::__anon1
kUndefined	matrix-common.h	/^  kUndefined,$/;"	e	enum:kaldi::__anon2
kWithinStep	optimization.h	/^    kWithinStep, \/\/ This means we're within the step-size computation, and$/;"	e	enum:kaldi::OptimizeLbfgs::ComputationState
kWolfeI	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	e	enum:kaldi::OptimizeLbfgs::__anon4
kWolfeII	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	e	enum:kaldi::OptimizeLbfgs::__anon4
k_	optimization.h	/^  SignedMatrixIndexT k_; \/\/ Iteration number, starts from zero.  Gets set back to zero$/;"	m	class:kaldi::OptimizeLbfgs
kaldi	cblas-wrappers.h	/^namespace kaldi {$/;"	n
kaldi	compressed-matrix.cc	/^namespace kaldi {$/;"	n	file:
kaldi	compressed-matrix.h	/^namespace kaldi {$/;"	n
kaldi	jama-eig.h	/^namespace kaldi {$/;"	n
kaldi	jama-svd.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-gpsr-test.cc	/^namespace kaldi {$/;"	n	file:
kaldi	kaldi-gpsr.cc	/^namespace kaldi {$/;"	n	file:
kaldi	kaldi-gpsr.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-matrix-inl.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-matrix.cc	/^namespace kaldi {$/;"	n	file:
kaldi	kaldi-matrix.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-tensor-inl.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-tensor.cc	/^namespace kaldi {$/;"	n	file:
kaldi	kaldi-tensor.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-vector-inl.h	/^namespace kaldi {$/;"	n
kaldi	kaldi-vector.cc	/^namespace kaldi {$/;"	n	file:
kaldi	kaldi-vector.h	/^namespace kaldi {$/;"	n
kaldi	matrix-common.h	/^namespace kaldi {$/;"	n
kaldi	matrix-functions-inl.h	/^namespace kaldi {$/;"	n
kaldi	matrix-functions.cc	/^namespace kaldi {$/;"	n	file:
kaldi	matrix-functions.h	/^namespace kaldi {$/;"	n
kaldi	matrix-lib-test.cc	/^namespace kaldi {$/;"	n	file:
kaldi	optimization.cc	/^namespace kaldi {$/;"	n	file:
kaldi	optimization.h	/^namespace kaldi {$/;"	n
kaldi	packed-matrix.cc	/^namespace kaldi {$/;"	n	file:
kaldi	packed-matrix.h	/^namespace kaldi {$/;"	n
kaldi	qr.cc	/^namespace kaldi {$/;"	n	file:
kaldi	sp-matrix-inl.h	/^namespace kaldi {$/;"	n
kaldi	sp-matrix.cc	/^namespace kaldi {$/;"	n	file:
kaldi	sp-matrix.h	/^namespace kaldi {$/;"	n
kaldi	srfft.cc	/^namespace kaldi {$/;"	n	file:
kaldi	srfft.h	/^namespace kaldi {$/;"	n
kaldi	tp-matrix.cc	/^namespace kaldi {$/;"	n	file:
kaldi	tp-matrix.h	/^namespace kaldi {$/;"	n
kaldi::AddDimInfo	kaldi-tensor.cc	/^struct AddDimInfo {$/;"	s	namespace:kaldi	file:
kaldi::AddDimInfo::dim	kaldi-tensor.cc	/^  int32 dim; \/\/ dim we count up to.$/;"	m	struct:kaldi::AddDimInfo	file:
kaldi::AddDimInfo::stride0	kaldi-tensor.cc	/^  int32 stride0;  \/\/ stride of *this.$/;"	m	struct:kaldi::AddDimInfo	file:
kaldi::AddDimInfo::stride1	kaldi-tensor.cc	/^  int32 stride1;  \/\/ stride of t1$/;"	m	struct:kaldi::AddDimInfo	file:
kaldi::AddDimInfo::stride2	kaldi-tensor.cc	/^  int32 stride2;  \/\/ stride of t2.$/;"	m	struct:kaldi::AddDimInfo	file:
kaldi::AddOuterProductPlusMinus	matrix-functions.cc	/^void AddOuterProductPlusMinus(Real alpha,$/;"	f	namespace:kaldi
kaldi::ApproxEqual	kaldi-matrix.h	/^bool ApproxEqual(const MatrixBase<Real> &A,$/;"	f	namespace:kaldi
kaldi::ApproxEqual	kaldi-vector.h	/^bool ApproxEqual(const VectorBase<Real> &a,$/;"	f	namespace:kaldi
kaldi::ApproxEqual	sp-matrix.h	/^inline bool ApproxEqual(const SpMatrix<Real> &A,$/;"	f	namespace:kaldi
kaldi::AssertEqual	kaldi-matrix.h	/^inline void AssertEqual(MatrixBase<Real> &A, MatrixBase<Real> &B,$/;"	f	namespace:kaldi
kaldi::AssertEqual	kaldi-vector.h	/^inline void AssertEqual(VectorBase<Real> &a, VectorBase<Real> &b,$/;"	f	namespace:kaldi
kaldi::AssertEqual	sp-matrix.h	/^inline void AssertEqual(const SpMatrix<Real> &A,$/;"	f	namespace:kaldi
kaldi::AssertSameDim	matrix-functions.h	/^inline void AssertSameDim(const MatrixBase<Real1> &mat1, const MatrixBase<Real2> &mat2) {$/;"	f	namespace:kaldi
kaldi::AttemptComplexPower	kaldi-matrix.cc	/^bool AttemptComplexPower(Real *x_re, Real *x_im, Real power) {$/;"	f	namespace:kaldi
kaldi::CholeskyUnitTestTr	matrix-lib-test.cc	/^template<typename Real> static void CholeskyUnitTestTr() {$/;"	f	namespace:kaldi
kaldi::ComplexAddProduct	matrix-functions-inl.h	/^template<typename Real> inline void ComplexAddProduct(const Real &a_re, const Real &a_im,$/;"	f	namespace:kaldi
kaldi::ComplexFft	matrix-functions.cc	/^template<typename Real> void ComplexFft(VectorBase<Real> *v, bool forward, Vector<Real> *tmp_in) {$/;"	f	namespace:kaldi
kaldi::ComplexFftRecursive	matrix-functions.cc	/^void ComplexFftRecursive (Real *data, int nffts, int N,$/;"	f	namespace:kaldi
kaldi::ComplexFt	matrix-functions.cc	/^template<typename Real> void ComplexFt (const VectorBase<Real> &in,$/;"	f	namespace:kaldi
kaldi::ComplexImExp	matrix-functions-inl.h	/^template<typename Real> inline void ComplexImExp(Real x, Real *a_re, Real *a_im) {$/;"	f	namespace:kaldi
kaldi::ComplexMul	matrix-functions-inl.h	/^template<typename Real> inline void ComplexMul(const Real &a_re, const Real &a_im,$/;"	f	namespace:kaldi
kaldi::CompressedMatrix	compressed-matrix.h	/^class CompressedMatrix {$/;"	c	namespace:kaldi
kaldi::CompressedMatrix::AllocateData	compressed-matrix.cc	/^void* CompressedMatrix::AllocateData(int32 num_bytes) {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CharToFloat	compressed-matrix.cc	/^inline float CompressedMatrix::CharToFloat($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CompressColumn	compressed-matrix.cc	/^void CompressedMatrix::CompressColumn($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CompressedMatrix	compressed-matrix.cc	/^CompressedMatrix::CompressedMatrix(const CompressedMatrix &mat): data_(NULL) {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CompressedMatrix	compressed-matrix.h	/^  CompressedMatrix(): data_(NULL) { }$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CompressedMatrix	compressed-matrix.h	/^  CompressedMatrix(const MatrixBase<Real> &mat): data_(NULL) { CopyFromMat(mat); }$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::ComputeColHeader	compressed-matrix.cc	/^void CompressedMatrix::ComputeColHeader($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CopyColToVec	compressed-matrix.cc	/^void CompressedMatrix::CopyColToVec(MatrixIndexT col,$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CopyFromMat	compressed-matrix.cc	/^void CompressedMatrix::CopyFromMat($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CopyRowToVec	compressed-matrix.cc	/^void CompressedMatrix::CopyRowToVec(MatrixIndexT row,$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CopyToMat	compressed-matrix.cc	/^void CompressedMatrix::CopyToMat(MatrixBase<Real> *mat) const {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::CopyToMat	compressed-matrix.cc	/^void CompressedMatrix::CopyToMat(int32 row_offset,$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::DataSize	compressed-matrix.h	/^  static MatrixIndexT DataSize(const GlobalHeader &header) {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::Destroy	compressed-matrix.cc	/^void CompressedMatrix::Destroy() {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::FloatToChar	compressed-matrix.cc	/^inline unsigned char CompressedMatrix::FloatToChar($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::FloatToUint16	compressed-matrix.cc	/^inline uint16 CompressedMatrix::FloatToUint16($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::GlobalHeader	compressed-matrix.h	/^  struct GlobalHeader {$/;"	s	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::GlobalHeader::min_value	compressed-matrix.h	/^    float min_value;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
kaldi::CompressedMatrix::GlobalHeader::num_cols	compressed-matrix.h	/^    int32 num_cols;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
kaldi::CompressedMatrix::GlobalHeader::num_rows	compressed-matrix.h	/^    int32 num_rows;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
kaldi::CompressedMatrix::GlobalHeader::range	compressed-matrix.h	/^    float range;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
kaldi::CompressedMatrix::NumCols	compressed-matrix.h	/^  inline MatrixIndexT NumCols() const { return (data_ == NULL) ? 0 :$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::NumRows	compressed-matrix.h	/^  inline MatrixIndexT NumRows() const { return (data_ == NULL) ? 0 :$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::PerColHeader	compressed-matrix.h	/^  struct PerColHeader {$/;"	s	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::PerColHeader::percentile_0	compressed-matrix.h	/^    uint16 percentile_0;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
kaldi::CompressedMatrix::PerColHeader::percentile_100	compressed-matrix.h	/^    uint16 percentile_100;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
kaldi::CompressedMatrix::PerColHeader::percentile_25	compressed-matrix.h	/^    uint16 percentile_25;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
kaldi::CompressedMatrix::PerColHeader::percentile_75	compressed-matrix.h	/^    uint16 percentile_75;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
kaldi::CompressedMatrix::Read	compressed-matrix.cc	/^void CompressedMatrix::Read(std::istream &is, bool binary) {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::Swap	compressed-matrix.h	/^  void Swap(CompressedMatrix *other) { std::swap(data_, other->data_); }$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::Uint16ToFloat	compressed-matrix.cc	/^inline float CompressedMatrix::Uint16ToFloat($/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::Write	compressed-matrix.cc	/^void CompressedMatrix::Write(std::ostream &os, bool binary) const {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::data_	compressed-matrix.h	/^  void *data_; \/\/ first GlobalHeader, then PerColHeader (repeated), then$/;"	m	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::operator =	compressed-matrix.cc	/^CompressedMatrix &CompressedMatrix::operator = (const CompressedMatrix &mat) {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::operator =	compressed-matrix.cc	/^CompressedMatrix &CompressedMatrix::operator =(const MatrixBase<Real> &mat) {$/;"	f	class:kaldi::CompressedMatrix
kaldi::CompressedMatrix::~CompressedMatrix	compressed-matrix.h	/^  ~CompressedMatrix() { Destroy(); }$/;"	f	class:kaldi::CompressedMatrix
kaldi::ComputeDctMatrix	matrix-functions.cc	/^template<typename Real> void ComputeDctMatrix(Matrix<Real> *M) {$/;"	f	namespace:kaldi
kaldi::ComputePca	matrix-functions.cc	/^void ComputePca(const MatrixBase<Real> &X,$/;"	f	namespace:kaldi
kaldi::CreateEigenvalueMatrix	kaldi-matrix.cc	/^void CreateEigenvalueMatrix(const VectorBase<Real> &re, const VectorBase<Real> &im,$/;"	f	namespace:kaldi
kaldi::Debias	kaldi-gpsr.cc	/^double Debias(const GpsrConfig &opts, const SpMatrix<double> &H,$/;"	f	namespace:kaldi
kaldi::DoubleFactorial	matrix-lib-test.cc	/^static int32 DoubleFactorial(int32 i) {$/;"	f	namespace:kaldi
kaldi::EigenvalueDecomposition	jama-eig.h	/^template<typename Real> class EigenvalueDecomposition {$/;"	c	namespace:kaldi
kaldi::EigenvalueDecomposition::EigenvalueDecomposition	jama-eig.h	/^EigenvalueDecomposition<Real>::EigenvalueDecomposition(const MatrixBase<Real> &A) {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::GetImagEigenvalues	jama-eig.h	/^  void GetImagEigenvalues(VectorBase<Real> *i_out) {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::GetRealEigenvalues	jama-eig.h	/^  void GetRealEigenvalues(VectorBase<Real> *r_out) {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::GetV	jama-eig.h	/^  void GetV(MatrixBase<Real> *V_out) {  \/\/ V is what we call P externally; it's the matrix of$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::H	jama-eig.h	/^  inline Real &H(int r, int c) { return H_[r*n_ + c]; }$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::H_	jama-eig.h	/^  Real *H_;  \/\/ the nonsymmetric Hessenberg form.$/;"	m	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::Hqr2	jama-eig.h	/^template<typename Real> void  EigenvalueDecomposition<Real>::Hqr2() {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::Orthes	jama-eig.h	/^void EigenvalueDecomposition<Real>::Orthes() {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::Tql2	jama-eig.h	/^template<typename Real> void EigenvalueDecomposition<Real>::Tql2() {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::Tred2	jama-eig.h	/^template<typename Real> void  EigenvalueDecomposition<Real>::Tred2() {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::V	jama-eig.h	/^  inline Real &V(int r, int c) { return V_[r*n_ + c]; }$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::V_	jama-eig.h	/^  Real *V_;  \/\/ the eigenvectors (P in our external notation)$/;"	m	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::cdiv	jama-eig.h	/^  inline static void cdiv(Real xr, Real xi, Real yr, Real yi, Real *cdivr, Real *cdivi) {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::d_	jama-eig.h	/^  Real *d_, *e_;  \/\/ real and imaginary parts of eigenvalues.$/;"	m	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::e_	jama-eig.h	/^  Real *d_, *e_;  \/\/ real and imaginary parts of eigenvalues.$/;"	m	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::n_	jama-eig.h	/^  int n_;  \/\/ matrix dimension.$/;"	m	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::ort_	jama-eig.h	/^  Real *ort_;  \/\/ working storage for nonsymmetric algorithm.$/;"	m	class:kaldi::EigenvalueDecomposition
kaldi::EigenvalueDecomposition::~EigenvalueDecomposition	jama-eig.h	/^EigenvalueDecomposition<Real>::~EigenvalueDecomposition() {$/;"	f	class:kaldi::EigenvalueDecomposition
kaldi::Givens	qr.cc	/^inline void Givens(Real a, Real b, Real *c, Real *s) {$/;"	f	namespace:kaldi
kaldi::Gpsr	kaldi-gpsr.h	/^Real Gpsr(const GpsrConfig &opts, const SpMatrix<Real> &H,$/;"	f	namespace:kaldi
kaldi::GpsrBB	kaldi-gpsr.cc	/^double GpsrBB(const GpsrConfig &opts, const SpMatrix<double> &H,$/;"	f	namespace:kaldi
kaldi::GpsrBB	kaldi-gpsr.cc	/^float GpsrBB(const GpsrConfig &opts, const SpMatrix<float> &H,$/;"	f	namespace:kaldi
kaldi::GpsrBasic	kaldi-gpsr.cc	/^double GpsrBasic(const GpsrConfig &opts, const SpMatrix<double> &H,$/;"	f	namespace:kaldi
kaldi::GpsrBasic	kaldi-gpsr.cc	/^float GpsrBasic(const GpsrConfig &opts, const SpMatrix<float> &H,$/;"	f	namespace:kaldi
kaldi::GpsrBasicAlpha	kaldi-gpsr.cc	/^double GpsrBasicAlpha(const SpMatrix<double> &H, const Vector<double> &u,$/;"	f	namespace:kaldi
kaldi::GpsrCalcLinearCoeff	kaldi-gpsr.cc	/^void GpsrCalcLinearCoeff(double tau, const Vector<double> &g,$/;"	f	namespace:kaldi
kaldi::GpsrConfig	kaldi-gpsr.h	/^struct GpsrConfig {$/;"	s	namespace:kaldi
kaldi::GpsrConfig::GpsrConfig	kaldi-gpsr.h	/^  GpsrConfig() {$/;"	f	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::Register	kaldi-gpsr.h	/^inline void GpsrConfig::Register(OptionsItf *po) {$/;"	f	class:kaldi::GpsrConfig
kaldi::GpsrConfig::alpha_max	kaldi-gpsr.h	/^  double alpha_max;  \/\/\/< Maximum step size in the feasible direction$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::alpha_min	kaldi-gpsr.h	/^  double alpha_min;  \/\/\/< Minimum step size in the feasible direction$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::debias	kaldi-gpsr.h	/^  bool debias;  \/\/\/< Do debiasing, i.e. unconstrained optimization at the end$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::gpsr_beta	kaldi-gpsr.h	/^  double gpsr_beta;$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::gpsr_mu	kaldi-gpsr.h	/^  double gpsr_mu;$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::gpsr_tau	kaldi-gpsr.h	/^  double gpsr_tau;  \/\/\/< Regularization scale$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::max_iters	kaldi-gpsr.h	/^  int32 max_iters;  \/\/\/< Maximum number of iterations$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::max_iters_backtrak	kaldi-gpsr.h	/^  int32 max_iters_backtrak;  \/\/\/< Max iterations for backtracking line search$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::max_iters_debias	kaldi-gpsr.h	/^  int32 max_iters_debias;  \/\/\/< Maximum number of iterations for debiasing stage$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::max_sparsity	kaldi-gpsr.h	/^  double max_sparsity;  \/\/\/< Maximum percentage of dimensions set to 0$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::stop_thresh	kaldi-gpsr.h	/^  double stop_thresh;  \/\/\/< Stopping threshold$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::stop_thresh_debias	kaldi-gpsr.h	/^  double stop_thresh_debias;  \/\/\/< Stopping threshold for debiasing stage$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::tau_reduction	kaldi-gpsr.h	/^  double tau_reduction;  \/\/\/< Multiply tau by this if max_sparsity reached$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrConfig::use_gpsr_bb	kaldi-gpsr.h	/^  bool use_gpsr_bb;  \/\/\/< Use the Barzilai-Borwein gradient projection method$/;"	m	struct:kaldi::GpsrConfig
kaldi::GpsrGradient	kaldi-gpsr.cc	/^void GpsrGradient(const SpMatrix<double> &H, const Vector<double> &c,$/;"	f	namespace:kaldi
kaldi::GpsrObjective	kaldi-gpsr.cc	/^double GpsrObjective(const SpMatrix<double> &H, const Vector<double> &c,$/;"	f	namespace:kaldi
kaldi::House	qr.cc	/^void House(MatrixIndexT dim, const Real *x, Real *v, Real *beta) {$/;"	f	namespace:kaldi
kaldi::HouseBackward	qr.cc	/^void HouseBackward(MatrixIndexT dim, const Real *x, Real *v, Real *beta) {$/;"	f	namespace:kaldi
kaldi::HtkHeader	kaldi-matrix.h	/^struct HtkHeader {$/;"	s	namespace:kaldi
kaldi::HtkHeader::mNSamples	kaldi-matrix.h	/^  int32    mNSamples;$/;"	m	struct:kaldi::HtkHeader
kaldi::HtkHeader::mSampleKind	kaldi-matrix.h	/^  uint16   mSampleKind;$/;"	m	struct:kaldi::HtkHeader
kaldi::HtkHeader::mSamplePeriod	kaldi-matrix.h	/^  int32    mSamplePeriod;$/;"	m	struct:kaldi::HtkHeader
kaldi::HtkHeader::mSampleSize	kaldi-matrix.h	/^  int16    mSampleSize;$/;"	m	struct:kaldi::HtkHeader
kaldi::InitRand	kaldi-gpsr-test.cc	/^template<typename Real> static void InitRand(MatrixBase<Real> *M) {$/;"	f	namespace:kaldi
kaldi::InitRand	kaldi-gpsr-test.cc	/^template<typename Real> static void InitRand(SpMatrix<Real> *M) {$/;"	f	namespace:kaldi
kaldi::InitRand	kaldi-gpsr-test.cc	/^template<typename Real> static void InitRand(VectorBase<Real> *v) {$/;"	f	namespace:kaldi
kaldi::InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(MatrixBase<Real> *M) {$/;"	f	namespace:kaldi
kaldi::InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(SpMatrix<Real> *M) {$/;"	f	namespace:kaldi
kaldi::InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(TpMatrix<Real> *M) {$/;"	f	namespace:kaldi
kaldi::InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(Vector<Real> *v) {$/;"	f	namespace:kaldi
kaldi::InitRand	matrix-lib-test.cc	/^template<typename Real> static void InitRand(VectorBase<Real> *v) {$/;"	f	namespace:kaldi
kaldi::LbfgsOptions	optimization.h	/^struct LbfgsOptions {$/;"	s	namespace:kaldi
kaldi::LbfgsOptions::LbfgsOptions	optimization.h	/^  LbfgsOptions (bool minimize = true):$/;"	f	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::avg_step_length	optimization.h	/^  int avg_step_length; \/\/ number of iters to avg step length over, in$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::c1	optimization.h	/^  float c1; \/\/ A constant in Armijo rule = Wolfe condition i)$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::c2	optimization.h	/^  float c2; \/\/ A constant in Wolfe condition ii)$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::d	optimization.h	/^  float d; \/\/ An amount > 1.0 (default 2.0) that we initially multiply or$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::first_step_impr	optimization.h	/^  float first_step_impr; \/\/ If this variable is >0.0, it overrides$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::first_step_learning_rate	optimization.h	/^  float first_step_learning_rate; \/\/ The very first step of L-BFGS is$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::first_step_length	optimization.h	/^  float first_step_length; \/\/ If this variable is >0.0, it overrides$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::m	optimization.h	/^  int m; \/\/ m is the number of stored vectors L-BFGS keeps.$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::max_line_search_iters	optimization.h	/^  int max_line_search_iters; \/\/ after this many iters we restart L-BFGS.$/;"	m	struct:kaldi::LbfgsOptions
kaldi::LbfgsOptions::minimize	optimization.h	/^  bool minimize; \/\/ if true, we're minimizing, else maximizing.$/;"	m	struct:kaldi::LbfgsOptions
kaldi::Matrix	kaldi-matrix.h	/^class Matrix : public MatrixBase<Real> {$/;"	c	namespace:kaldi
kaldi::Matrix::Destroy	kaldi-matrix.cc	/^void Matrix<Real>::Destroy() {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Init	kaldi-matrix.cc	/^inline void Matrix<Real>::Init(const MatrixIndexT rows,$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix-inl.h	/^Matrix<Real>::Matrix(): MatrixBase<Real>(NULL, 0, 0, 0) { }$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix (const Matrix<Real> & M):$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix (const MatrixBase<Real> & M,$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix(const CompressedMatrix &M): MatrixBase<Real>() {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.cc	/^Matrix<Real>::Matrix(const MatrixBase<OtherReal> & M,$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.h	/^  Matrix(const MatrixIndexT r, const MatrixIndexT c,$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.h	/^  explicit Matrix(const SpMatrix<OtherReal> & M) : MatrixBase<Real>() {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Matrix	kaldi-matrix.h	/^  explicit Matrix(const TpMatrix<OtherReal> & M,$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Read	kaldi-matrix.cc	/^void Matrix<Real>::Read(std::istream & is, bool binary, bool add) {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::RemoveRow	kaldi-matrix.cc	/^void Matrix<Real>::RemoveRow(MatrixIndexT i) {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Resize	kaldi-matrix.cc	/^void Matrix<Real>::Resize(const MatrixIndexT rows,$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Swap	kaldi-matrix.cc	/^void Matrix<Real>::Swap(Matrix<Real> *other) {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::Transpose	kaldi-matrix.cc	/^void Matrix<Real>::Transpose() {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::operator =	kaldi-matrix.h	/^  Matrix<Real> &operator = (const Matrix<Real> &other) {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::operator =	kaldi-matrix.h	/^  Matrix<Real> &operator = (const MatrixBase<Real> &other) {$/;"	f	class:kaldi::Matrix
kaldi::Matrix::~Matrix	kaldi-matrix.h	/^  ~Matrix() { Destroy(); }$/;"	f	class:kaldi::Matrix
kaldi::MatrixBase	kaldi-matrix.h	/^class MatrixBase {$/;"	c	namespace:kaldi
kaldi::MatrixBase::Add	kaldi-matrix.cc	/^void MatrixBase<Real>::Add(const Real alpha) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddDiagVecMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddDiagVecMat($/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMat(const Real alpha, const MatrixBase<Real>& A,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMatMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMatMatDivMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatMatDivMat(const MatrixBase<Real>& A,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMatMatMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatMatMat(Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMatSmat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddMatSmat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMatSp	kaldi-matrix.h	/^  void AddMatSp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddMatTp	kaldi-matrix.h	/^  void AddMatTp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddSmatMat	kaldi-matrix.cc	/^void MatrixBase<Real>::AddSmatMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddSp	kaldi-matrix.cc	/^void MatrixBase<Real>::AddSp(const Real alpha, const SpMatrix<OtherReal> &S) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddSpMat	kaldi-matrix.h	/^  void AddSpMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddSpMatSp	kaldi-matrix.h	/^  void AddSpMatSp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddSpSp	kaldi-matrix.cc	/^void MatrixBase<Real>::AddSpSp(const Real alpha, const SpMatrix<Real> &A_in,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddToDiag	kaldi-matrix.cc	/^void MatrixBase<Real>::AddToDiag(const Real alpha) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddTpMat	kaldi-matrix.h	/^  void AddTpMat(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddTpTp	kaldi-matrix.h	/^  void AddTpTp(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddVecToCols	kaldi-matrix.cc	/^void MatrixBase<Real>::AddVecToCols(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddVecToRows	kaldi-matrix.cc	/^void MatrixBase<Real>::AddVecToRows(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddVecVec	kaldi-matrix.cc	/^void MatrixBase<Real>::AddVecVec(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddVecVec	kaldi-matrix.cc	/^void MatrixBase<double>::AddVecVec(const double alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::AddVecVec	kaldi-matrix.cc	/^void MatrixBase<float>::AddVecVec(const float alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplyCeiling	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyCeiling(Real ceiling_val) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplyExp	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyExp() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplyFloor	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyFloor(Real floor_val) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplyHeaviside	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyHeaviside() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplyLog	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyLog() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplyPow	kaldi-matrix.cc	/^void MatrixBase<Real>::ApplyPow(Real power) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApplySoftMax	kaldi-matrix.cc	/^Real MatrixBase<Real>::ApplySoftMax() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ApproxEqual	kaldi-matrix.cc	/^bool MatrixBase<Real>::ApproxEqual(const MatrixBase<Real> &other, float tol) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ColRange	kaldi-matrix.h	/^  inline SubMatrix<Real> ColRange(const MatrixIndexT col_offset,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Cond	kaldi-matrix.cc	/^Real MatrixBase<Real>::Cond() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::ConvMat	kaldi-matrix.cc	/^void MatrixBase<Real>::ConvMat(const MatrixBase<Real> &A, int block_dim_x, $/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyColFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyColFromVec(const VectorBase<Real> &rv,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyCols	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyCols(const MatrixBase<Real> &src,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyColsFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyColsFromVec(const VectorBase<Real> &rv) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyDiagFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyDiagFromVec(const VectorBase<Real> &rv) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyFromMat	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromMat(const CompressedMatrix &mat) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyFromMat	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromMat(const MatrixBase<OtherReal> & M,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyFromSp	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromSp(const SpMatrix<OtherReal> & M) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyFromSp	kaldi-matrix.cc	/^void MatrixBase<double>::CopyFromSp(const SpMatrix<double> & M) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyFromSp	kaldi-matrix.cc	/^void MatrixBase<float>::CopyFromSp(const SpMatrix<float> & M) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyFromTp	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyFromTp(const TpMatrix<OtherReal> & M,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyLowerToUpper	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyLowerToUpper() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyRowFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRowFromVec(const VectorBase<Real> &rv, const MatrixIndexT row) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyRows	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRows(const MatrixBase<Real> &src,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyRowsFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRowsFromVec(const VectorBase<OtherReal> &rv) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyRowsFromVec	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyRowsFromVec(const VectorBase<Real> &rv) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::CopyUpperToLower	kaldi-matrix.cc	/^void MatrixBase<Real>::CopyUpperToLower() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Data	kaldi-matrix.h	/^  inline Real* Data() { return data_; }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Data	kaldi-matrix.h	/^  inline const Real* Data() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Data_workaround	kaldi-matrix.h	/^  inline Real*  Data_workaround() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::DestructiveSvd	kaldi-matrix.cc	/^void MatrixBase<Real>::DestructiveSvd(VectorBase<Real> *s, MatrixBase<Real> *U, MatrixBase<Real> *Vt) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::DiffSigmoid	kaldi-matrix.cc	/^void MatrixBase<Real>::DiffSigmoid(const MatrixBase<Real> &value,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::DiffTanh	kaldi-matrix.cc	/^void MatrixBase<Real>::DiffTanh(const MatrixBase<Real> &value,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::DivElements	kaldi-matrix.cc	/^void MatrixBase<Real>::DivElements(const MatrixBase<Real> &a) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Eig	kaldi-matrix.cc	/^void MatrixBase<Real>::Eig(MatrixBase<Real> *P,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Equal	kaldi-matrix.cc	/^bool MatrixBase<Real>::Equal(const MatrixBase<Real> &other) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::FrobeniusNorm	kaldi-matrix.cc	/^Real MatrixBase<Real>::FrobeniusNorm() const{$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::GroupPnorm	kaldi-matrix.cc	/^void MatrixBase<Real>::GroupPnorm(const MatrixBase<Real> &src, Real power) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::GroupPnormDeriv	kaldi-matrix.cc	/^void MatrixBase<Real>::GroupPnormDeriv(const MatrixBase<Real> &src1,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Index	kaldi-matrix.h	/^  Real &Index (MatrixIndexT r, MatrixIndexT c) {  return (*this)(r, c); }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Invert	kaldi-matrix.cc	/^void MatrixBase<Real>::Invert(Real *log_det, Real *det_sign,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::InvertDouble	kaldi-matrix.cc	/^void MatrixBase<Real>::InvertDouble(Real *log_det, Real *det_sign,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::InvertElements	kaldi-matrix.cc	/^void MatrixBase<Real>::InvertElements() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::IsDiagonal	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsDiagonal(Real cutoff) const{$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::IsSymmetric	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsSymmetric(Real cutoff) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::IsUnit	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsUnit(Real cutoff) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::IsZero	kaldi-matrix.cc	/^bool MatrixBase<Real>::IsZero(Real cutoff)const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::JamaSvd	jama-svd.h	/^bool MatrixBase<Real>::JamaSvd(VectorBase<Real> *s_in,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::LapackGesvd	kaldi-matrix.cc	/^void MatrixBase<Real>::LapackGesvd(VectorBase<Real> *s, MatrixBase<Real> *U_in, $/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::LargestAbsElem	kaldi-matrix.cc	/^Real MatrixBase<Real>::LargestAbsElem() const{$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::LogDet	kaldi-matrix.cc	/^Real MatrixBase<Real>::LogDet(Real *det_sign) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::LogSumExp	kaldi-matrix.cc	/^Real MatrixBase<Real>::LogSumExp(Real prune) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MatrixBase	kaldi-matrix.h	/^  explicit MatrixBase(): data_(NULL) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MatrixBase	kaldi-matrix.h	/^  explicit MatrixBase(Real *data, MatrixIndexT cols, MatrixIndexT rows, MatrixIndexT stride) :$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Max	kaldi-matrix.cc	/^Real MatrixBase<Real>::Max() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Max	kaldi-matrix.cc	/^template<typename Real> void MatrixBase<Real>::Max(const MatrixBase<Real> &A) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Min	kaldi-matrix.cc	/^Real MatrixBase<Real>::Min() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MinSingularValue	kaldi-matrix.h	/^  Real MinSingularValue() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MulColsVec	kaldi-matrix.cc	/^void MatrixBase<Real>::MulColsVec(const VectorBase<Real> &scale) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MulElements	kaldi-matrix.cc	/^void MatrixBase<Real>::MulElements(const MatrixBase<Real> &a) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MulRowsGroupMat	kaldi-matrix.cc	/^void MatrixBase<Real>::MulRowsGroupMat(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::MulRowsVec	kaldi-matrix.cc	/^void MatrixBase<Real>::MulRowsVec(const VectorBase<Real> &scale) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::NumCols	kaldi-matrix.h	/^  inline MatrixIndexT NumCols() const { return num_cols_; }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::NumRows	kaldi-matrix.h	/^  inline MatrixIndexT  NumRows() const { return num_rows_; }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::OrthogonalizeRows	kaldi-matrix.cc	/^void MatrixBase<Real>::OrthogonalizeRows() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Power	kaldi-matrix.cc	/^bool MatrixBase<Real>::Power(Real power) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Range	kaldi-matrix.h	/^  inline SubMatrix<Real> Range(const MatrixIndexT row_offset,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Read	kaldi-matrix.cc	/^void MatrixBase<Real>::Read(std::istream & is, bool binary, bool add) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Row	kaldi-matrix.h	/^  inline SubVector<Real> Row(MatrixIndexT i) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Row	kaldi-matrix.h	/^  inline const SubVector<Real> Row(MatrixIndexT i) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::RowData	kaldi-matrix.h	/^  inline  Real* RowData(MatrixIndexT i) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::RowData	kaldi-matrix.h	/^  inline const Real* RowData(MatrixIndexT i) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::RowRange	kaldi-matrix.h	/^  inline SubMatrix<Real> RowRange(const MatrixIndexT row_offset,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Scale	kaldi-matrix.cc	/^template<typename Real> void MatrixBase<Real>::Scale(Real alpha) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Set	kaldi-matrix.cc	/^void MatrixBase<Real>::Set(Real value) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SetRandUniform	kaldi-matrix.cc	/^void MatrixBase<Real>::SetRandUniform() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SetRandn	kaldi-matrix.cc	/^void MatrixBase<Real>::SetRandn() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SetUnit	kaldi-matrix.cc	/^void MatrixBase<Real>::SetUnit() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SetZero	kaldi-matrix.cc	/^void MatrixBase<Real>::SetZero() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Sigmoid	kaldi-matrix.cc	/^void MatrixBase<Real>::Sigmoid(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SizeInBytes	kaldi-matrix.h	/^  size_t  SizeInBytes() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SoftHinge	kaldi-matrix.cc	/^void MatrixBase<Real>::SoftHinge(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Stride	kaldi-matrix.h	/^  inline MatrixIndexT Stride() const {  return stride_; }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Sum	kaldi-matrix.cc	/^Real MatrixBase<Real>::Sum() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Svd	kaldi-matrix.cc	/^void MatrixBase<Real>::Svd(VectorBase<Real> *s, MatrixBase<Real> *U, MatrixBase<Real> *Vt) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Svd	kaldi-matrix.h	/^  void Svd(VectorBase<Real> *s) const { Svd(s, NULL, NULL); }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SymAddMat2	kaldi-matrix.cc	/^void MatrixBase<Real>::SymAddMat2(const Real alpha,$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::SymPosSemiDefEig	kaldi-matrix.cc	/^void MatrixBase<Real>::SymPosSemiDefEig(VectorBase<Real> *rs, MatrixBase<Real> *rU, Real check_thresh) \/\/ e.g. check_thresh = 0.001$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Tanh	kaldi-matrix.cc	/^void MatrixBase<Real>::Tanh(const MatrixBase<Real> &src) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::TestUninitialized	kaldi-matrix.cc	/^void MatrixBase<Real>::TestUninitialized() const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Trace	kaldi-matrix.cc	/^Real MatrixBase<Real>::Trace(bool check_square) const  {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Transpose	kaldi-matrix.cc	/^void MatrixBase<Real>::Transpose() {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::Write	kaldi-matrix.cc	/^void MatrixBase<Real>::Write(std::ostream &os, bool binary) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::data_	kaldi-matrix.h	/^  Real*   data_;$/;"	m	class:kaldi::MatrixBase
kaldi::MatrixBase::num_cols_	kaldi-matrix.h	/^  MatrixIndexT    num_cols_;   \/\/\/ < Number of columns$/;"	m	class:kaldi::MatrixBase
kaldi::MatrixBase::num_rows_	kaldi-matrix.h	/^  MatrixIndexT    num_rows_;   \/\/\/ < Number of rows$/;"	m	class:kaldi::MatrixBase
kaldi::MatrixBase::operator ()	kaldi-matrix.h	/^  inline Real&  operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::operator ()	kaldi-matrix.h	/^  inline const Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixBase::stride_	kaldi-matrix.h	/^  MatrixIndexT    stride_;$/;"	m	class:kaldi::MatrixBase
kaldi::MatrixBase::~MatrixBase	kaldi-matrix.h	/^  ~MatrixBase() { }$/;"	f	class:kaldi::MatrixBase
kaldi::MatrixExponential	matrix-functions.h	/^class MatrixExponential {$/;"	c	namespace:kaldi
kaldi::MatrixExponential::B_	matrix-functions.h	/^  std::vector<Matrix<Real> > B_;  \/\/ B_[0] = exp(P_) - I,$/;"	m	class:kaldi::MatrixExponential
kaldi::MatrixExponential::Backprop	matrix-functions.cc	/^void MatrixExponential<Real>::Backprop(const MatrixBase<Real> &hX,$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::Backprop	matrix-functions.cc	/^void MatrixExponential<Real>::Backprop(const SpMatrix<Real> &hX,$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::BackpropTaylor	matrix-functions.cc	/^void MatrixExponential<Real>::BackpropTaylor(const MatrixBase<Real> &hB0,$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::Clear	matrix-functions.cc	/^void MatrixExponential<Real>::Clear() {$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::Compute	matrix-functions.cc	/^void MatrixExponential<Real>::Compute(const MatrixBase<Real> &M,$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::Compute	matrix-functions.cc	/^void MatrixExponential<Real>::Compute(const SpMatrix<Real> &M,$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::ComputeN	matrix-functions.cc	/^MatrixIndexT MatrixExponential<Real>::ComputeN(const MatrixBase<Real> &M) {$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::ComputeTaylor	matrix-functions.cc	/^void MatrixExponential<Real>::ComputeTaylor(const MatrixBase<Real> &P, MatrixBase<Real> *B0) {$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::MatrixExponential	matrix-functions.h	/^  MatrixExponential() { }$/;"	f	class:kaldi::MatrixExponential
kaldi::MatrixExponential::N_	matrix-functions.h	/^  MatrixIndexT N_;  \/\/ Power N_ >=0 such that P_ = A * 2^(-N_),$/;"	m	class:kaldi::MatrixExponential
kaldi::MatrixExponential::P_	matrix-functions.h	/^  Matrix<Real> P_;  \/\/ Equals M * 2^(-N_)$/;"	m	class:kaldi::MatrixExponential
kaldi::MatrixExponential::powers_	matrix-functions.h	/^  std::vector<Matrix<Real> > powers_;  \/\/ powers (>1) of P_ stored here,$/;"	m	class:kaldi::MatrixExponential
kaldi::MatrixIndexT	matrix-common.h	/^typedef int32 MatrixIndexT;$/;"	t	namespace:kaldi
kaldi::MatrixResizeType	matrix-common.h	/^} MatrixResizeType;$/;"	t	namespace:kaldi	typeref:enum:kaldi::__anon2
kaldi::MatrixTransposeType	matrix-common.h	/^} MatrixTransposeType;$/;"	t	namespace:kaldi	typeref:enum:kaldi::__anon1
kaldi::MatrixUnitTest	matrix-lib-test.cc	/^template<typename Real> static void MatrixUnitTest(bool full_test) {$/;"	f	namespace:kaldi
kaldi::NonDiagonalness	matrix-lib-test.cc	/^static Real NonDiagonalness(const SpMatrix<Real> &S) {$/;"	f	namespace:kaldi
kaldi::NonOrthogonality	matrix-lib-test.cc	/^static Real NonOrthogonality(const MatrixBase<Real> &M, MatrixTransposeType transM) {$/;"	f	namespace:kaldi
kaldi::NonUnitness	matrix-lib-test.cc	/^static Real NonUnitness(const SpMatrix<Real> &S) {$/;"	f	namespace:kaldi
kaldi::OptimizeLbfgs	optimization.h	/^class OptimizeLbfgs {$/;"	c	namespace:kaldi
kaldi::OptimizeLbfgs::AcceptStep	optimization.cc	/^bool OptimizeLbfgs<Real>::AcceptStep(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::ComputationState	optimization.h	/^  enum ComputationState {$/;"	g	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::ComputeHifNeeded	optimization.cc	/^void OptimizeLbfgs<Real>::ComputeHifNeeded(const VectorBase<Real> &gradient) {$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::ComputeNewDirection	optimization.cc	/^void OptimizeLbfgs<Real>::ComputeNewDirection(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::Dim	optimization.h	/^  inline MatrixIndexT Dim() { return x_.Dim(); }$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::DoStep	optimization.cc	/^void OptimizeLbfgs<Real>::DoStep(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::GetProposedValue	optimization.h	/^  const VectorBase<Real>& GetProposedValue() const { return new_x_; }$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::GetValue	optimization.cc	/^OptimizeLbfgs<Real>::GetValue(Real *objf_value) const {$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::H_	optimization.h	/^  Vector<Real> H_; \/\/ Current inverse-Hessian estimate.  May be computed by this class itself,$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::H_was_set_	optimization.h	/^  bool H_was_set_; \/\/ True if the user specified H_; if false,$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::M	optimization.h	/^  inline MatrixIndexT M() { return opts_.m; }$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::OptimizeLbfgs	optimization.cc	/^OptimizeLbfgs<Real>::OptimizeLbfgs(const VectorBase<Real> &x,$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::RecentStepLength	optimization.cc	/^Real OptimizeLbfgs<Real>::RecentStepLength() const {$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::RecordStepLength	optimization.cc	/^void OptimizeLbfgs<Real>::RecordStepLength(Real s) {$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::Restart	optimization.cc	/^void OptimizeLbfgs<Real>::Restart(const VectorBase<Real> &x,$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::S	optimization.h	/^  SubVector<Real> S(MatrixIndexT i) {$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::StepSizeIteration	optimization.cc	/^void OptimizeLbfgs<Real>::StepSizeIteration(Real function_value,$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::Y	optimization.h	/^  SubVector<Real> Y(MatrixIndexT i) {$/;"	f	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::best_f_	optimization.h	/^  Real best_f_; \/\/ the best objective function so far.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::best_x_	optimization.h	/^  Vector<Real> best_x_; \/\/ the x with the best objective function so far$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::computation_state_	optimization.h	/^  ComputationState computation_state_;$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::d_	optimization.h	/^  Real d_; \/\/ a number d > 1.0, but during an iteration we may decrease this, when$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::data_	optimization.h	/^  Matrix<Real> data_; \/\/ dimension (m*2) x dim.  Even rows store$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::deriv_	optimization.h	/^  Vector<Real> deriv_; \/\/ The most recently evaluated derivative-- at x_k.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::f_	optimization.h	/^  Real f_; \/\/ The function evaluated at x_k.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::kBeforeStep	optimization.h	/^    kBeforeStep,$/;"	e	enum:kaldi::OptimizeLbfgs::ComputationState
kaldi::OptimizeLbfgs::kNone	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	e	enum:kaldi::OptimizeLbfgs::__anon4
kaldi::OptimizeLbfgs::kWithinStep	optimization.h	/^    kWithinStep, \/\/ This means we're within the step-size computation, and$/;"	e	enum:kaldi::OptimizeLbfgs::ComputationState
kaldi::OptimizeLbfgs::kWolfeI	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	e	enum:kaldi::OptimizeLbfgs::__anon4
kaldi::OptimizeLbfgs::kWolfeII	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	e	enum:kaldi::OptimizeLbfgs::__anon4
kaldi::OptimizeLbfgs::k_	optimization.h	/^  SignedMatrixIndexT k_; \/\/ Iteration number, starts from zero.  Gets set back to zero$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::last_failure_type_	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	m	class:kaldi::OptimizeLbfgs	typeref:enum:kaldi::OptimizeLbfgs::__anon4
kaldi::OptimizeLbfgs::new_x_	optimization.h	/^  Vector<Real> new_x_; \/\/ the x proposed in the line search.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::num_wolfe_i_failures_	optimization.h	/^  int num_wolfe_i_failures_; \/\/ the num times we decreased step size.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::num_wolfe_ii_failures_	optimization.h	/^  int num_wolfe_ii_failures_; \/\/ the num times we increased step size.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::opts_	optimization.h	/^  LbfgsOptions opts_;$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::rho_	optimization.h	/^  Vector<Real> rho_; \/\/ dimension m; rho_(m) = 1\/(y_m^T s_m), Eq. 7.17.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::step_lengths_	optimization.h	/^  std::vector<Real> step_lengths_; \/\/ The step sizes we took on the last$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::temp_	optimization.h	/^  Vector<Real> temp_;$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OptimizeLbfgs::x_	optimization.h	/^  Vector<Real> x_; \/\/ current x.$/;"	m	class:kaldi::OptimizeLbfgs
kaldi::OtherReal	matrix-common.h	/^template<> class OtherReal<double> {$/;"	c	namespace:kaldi
kaldi::OtherReal	matrix-common.h	/^template<> class OtherReal<float> {$/;"	c	namespace:kaldi
kaldi::OtherReal	matrix-common.h	/^template<typename T> class OtherReal { };  \/\/ useful in reading+writing routines$/;"	c	namespace:kaldi
kaldi::OtherReal::Real	matrix-common.h	/^  typedef double Real;$/;"	t	class:kaldi::OtherReal
kaldi::OtherReal::Real	matrix-common.h	/^  typedef float Real;$/;"	t	class:kaldi::OtherReal
kaldi::PackedMatrix	packed-matrix.h	/^template<typename Real> class PackedMatrix {$/;"	c	namespace:kaldi
kaldi::PackedMatrix::AddPacked	packed-matrix.cc	/^void PackedMatrix<Real>::AddPacked(const Real alpha, const PackedMatrix<Real> &rMa) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::AddToDiag	packed-matrix.cc	/^void PackedMatrix<Real>::AddToDiag(Real r) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::CopyFromPacked	packed-matrix.cc	/^void PackedMatrix<Real>::CopyFromPacked(const PackedMatrix<OtherReal> &orig) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::CopyFromVec	packed-matrix.cc	/^void PackedMatrix<Real>::CopyFromVec(const SubVector<OtherReal> &vec) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Data	packed-matrix.h	/^  Real* Data() { return data_; }$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Data	packed-matrix.h	/^  const Real* Data() const { return data_; }$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Destroy	packed-matrix.cc	/^void PackedMatrix<Real>::Destroy() {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Init	packed-matrix.cc	/^inline void PackedMatrix<Real>::Init(MatrixIndexT r) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Max	packed-matrix.h	/^  Real Max() const {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Min	packed-matrix.h	/^  Real Min() const {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::NumCols	packed-matrix.h	/^  inline MatrixIndexT NumCols() const { return num_rows_; }$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::NumRows	packed-matrix.h	/^  inline MatrixIndexT NumRows() const { return num_rows_; }$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::PackedMatrix	packed-matrix.h	/^  PackedMatrix() : data_(NULL), num_rows_(0) {}$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::PackedMatrix	packed-matrix.h	/^  explicit PackedMatrix(MatrixIndexT r, MatrixResizeType resize_type = kSetZero):$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::PackedMatrix	packed-matrix.h	/^  explicit PackedMatrix(const PackedMatrix<OtherReal> &orig) : data_(NULL) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::PackedMatrix	packed-matrix.h	/^  explicit PackedMatrix(const PackedMatrix<Real> &orig) : data_(NULL) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Read	packed-matrix.cc	/^void PackedMatrix<Real>::Read(std::istream& is, bool binary, bool add) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Resize	packed-matrix.cc	/^void PackedMatrix<Real>::Resize(MatrixIndexT r, MatrixResizeType resize_type) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Scale	packed-matrix.cc	/^void PackedMatrix<Real>::Scale(Real alpha) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::ScaleDiag	packed-matrix.cc	/^void PackedMatrix<Real>::ScaleDiag(Real alpha) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::SetDiag	packed-matrix.cc	/^void PackedMatrix<Real>::SetDiag(Real alpha) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::SetRandn	packed-matrix.cc	/^void PackedMatrix<Real>::SetRandn() {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::SetUnit	packed-matrix.cc	/^void PackedMatrix<Real>::SetUnit() {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::SetZero	packed-matrix.cc	/^void PackedMatrix<Real>::SetZero() {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::SizeInBytes	packed-matrix.h	/^  size_t SizeInBytes() const {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Swap	packed-matrix.cc	/^void PackedMatrix<Real>::Swap(Matrix<Real> *other) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Swap	packed-matrix.cc	/^void PackedMatrix<Real>::Swap(PackedMatrix<Real> *other) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Trace	packed-matrix.cc	/^Real PackedMatrix<Real>::Trace() const {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::Write	packed-matrix.cc	/^void PackedMatrix<Real>::Write(std::ostream &os, bool binary) const {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::data_	packed-matrix.h	/^  Real *data_;$/;"	m	class:kaldi::PackedMatrix
kaldi::PackedMatrix::num_rows_	packed-matrix.h	/^  MatrixIndexT num_rows_;$/;"	m	class:kaldi::PackedMatrix
kaldi::PackedMatrix::operator ()	packed-matrix.h	/^  Real &operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::operator ()	packed-matrix.h	/^  Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::operator =	packed-matrix.h	/^  PackedMatrix<Real> & operator =(const PackedMatrix<Real> &other) {$/;"	f	class:kaldi::PackedMatrix
kaldi::PackedMatrix::~PackedMatrix	packed-matrix.h	/^  ~PackedMatrix() {$/;"	f	class:kaldi::PackedMatrix
kaldi::QrInternal	qr.cc	/^void QrInternal(MatrixIndexT n,$/;"	f	namespace:kaldi
kaldi::QrStep	qr.cc	/^void QrStep(MatrixIndexT n,$/;"	f	namespace:kaldi
kaldi::RandPosdefSpMatrix	matrix-lib-test.cc	/^void RandPosdefSpMatrix(MatrixIndexT dim, SpMatrix<Real> *matrix) {$/;"	f	namespace:kaldi
kaldi::ReadHtk	kaldi-matrix.cc	/^bool ReadHtk(std::istream &is, Matrix<Real> *M_ptr, HtkHeader *header_ptr)$/;"	f	namespace:kaldi
kaldi::RealFft	matrix-functions.cc	/^template<typename Real> void RealFft (VectorBase<Real> *v, bool forward) {$/;"	f	namespace:kaldi
kaldi::RealFftInefficient	matrix-functions.cc	/^template<typename Real> void RealFftInefficient (VectorBase<Real> *v, bool forward) {$/;"	f	namespace:kaldi
kaldi::SameDim	kaldi-matrix.h	/^bool SameDim(const MatrixBase<Real> &M, const MatrixBase<Real> &N) {$/;"	f	namespace:kaldi
kaldi::SignedMatrixIndexT	matrix-common.h	/^typedef int32 SignedMatrixIndexT;$/;"	t	namespace:kaldi
kaldi::SlowMatMul	matrix-lib-test.cc	/^template<typename Real> static void SlowMatMul() {$/;"	f	namespace:kaldi
kaldi::SolveDoubleQuadraticMatrixProblem	sp-matrix.cc	/^Real SolveDoubleQuadraticMatrixProblem(const MatrixBase<Real> &G,$/;"	f	namespace:kaldi
kaldi::SolveQuadraticMatrixProblem	sp-matrix.cc	/^SolveQuadraticMatrixProblem(const SpMatrix<Real> &Q,$/;"	f	namespace:kaldi
kaldi::SolveQuadraticProblem	sp-matrix.cc	/^template<> double SolveQuadraticProblem(const SpMatrix<double> &H,$/;"	f	namespace:kaldi
kaldi::SolveQuadraticProblem	sp-matrix.cc	/^template<> float SolveQuadraticProblem(const SpMatrix<float> &H,$/;"	f	namespace:kaldi
kaldi::SolverOptions	sp-matrix.h	/^struct SolverOptions {$/;"	s	namespace:kaldi
kaldi::SolverOptions::Check	sp-matrix.cc	/^void SolverOptions::Check() const {$/;"	f	class:kaldi::SolverOptions
kaldi::SolverOptions::K	sp-matrix.h	/^  BaseFloat K; \/\/ maximum condition number$/;"	m	struct:kaldi::SolverOptions
kaldi::SolverOptions::SolverOptions	sp-matrix.h	/^  SolverOptions(): K(1.0e+4), eps(1.0e-40), name("[unknown]"),$/;"	f	struct:kaldi::SolverOptions
kaldi::SolverOptions::SolverOptions	sp-matrix.h	/^  explicit SolverOptions(const std::string &name):$/;"	f	struct:kaldi::SolverOptions
kaldi::SolverOptions::diagonal_precondition	sp-matrix.h	/^  bool diagonal_precondition;$/;"	m	struct:kaldi::SolverOptions
kaldi::SolverOptions::eps	sp-matrix.h	/^  BaseFloat eps; $/;"	m	struct:kaldi::SolverOptions
kaldi::SolverOptions::name	sp-matrix.h	/^  std::string name;$/;"	m	struct:kaldi::SolverOptions
kaldi::SolverOptions::optimize_delta	sp-matrix.h	/^  bool optimize_delta;$/;"	m	struct:kaldi::SolverOptions
kaldi::SolverOptions::print_debug_output	sp-matrix.h	/^  bool print_debug_output;$/;"	m	struct:kaldi::SolverOptions
kaldi::SortSvd	kaldi-matrix.cc	/^template<typename Real> void  SortSvd(VectorBase<Real> *s, MatrixBase<Real> *U,$/;"	f	namespace:kaldi
kaldi::SpCopyType	matrix-common.h	/^} SpCopyType;$/;"	t	namespace:kaldi	typeref:enum:kaldi::__anon3
kaldi::SpMatrix	sp-matrix.h	/^class SpMatrix : public PackedMatrix<Real> {$/;"	c	namespace:kaldi
kaldi::SpMatrix::AddMat2	sp-matrix.cc	/^void SpMatrix<Real>::AddMat2(const Real alpha, const MatrixBase<Real> &M,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddMat2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddMat2Sp($/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddMat2Vec	sp-matrix.cc	/^void SpMatrix<Real>::AddMat2Vec(const Real alpha,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddSmat2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddSmat2Sp($/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddSp	sp-matrix.h	/^  void AddSp(const Real alpha, const SpMatrix<Real> &Ma) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddTp2	sp-matrix.cc	/^void SpMatrix<Real>::AddTp2(const Real alpha, const TpMatrix<Real> &T,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddTp2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddTp2Sp(const Real alpha, const TpMatrix<Real> &T,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddVec	sp-matrix.cc	/^void  SpMatrix<Real>::AddVec(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddVec2	sp-matrix.cc	/^void SpMatrix<Real>::AddVec2(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddVec2	sp-matrix.cc	/^void SpMatrix<double>::AddVec2(const double alpha, const VectorBase<double> &v) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddVec2	sp-matrix.cc	/^void SpMatrix<float>::AddVec2(const float alpha, const VectorBase<float> &v) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddVec2Sp	sp-matrix.cc	/^void SpMatrix<Real>::AddVec2Sp(const Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::AddVecVec	sp-matrix.cc	/^void SpMatrix<Real>::AddVecVec(const Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::ApplyFloor	sp-matrix.cc	/^int SpMatrix<Real>::ApplyFloor(Real floor) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::ApplyFloor	sp-matrix.cc	/^int SpMatrix<Real>::ApplyFloor(const SpMatrix<Real> &C, Real alpha,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::ApplyPow	sp-matrix.cc	/^void SpMatrix<Real>::ApplyPow(Real power) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::ApproxEqual	sp-matrix.cc	/^bool SpMatrix<Real>::ApproxEqual(const SpMatrix<Real> &other, float tol) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Cond	sp-matrix.h	/^  inline Real Cond() const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::CopyFromMat	sp-matrix.cc	/^void SpMatrix<Real>::CopyFromMat(const MatrixBase<Real> &M,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::CopyFromSp	sp-matrix.h	/^  void CopyFromSp(const SpMatrix<OtherReal> &other) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::CopyFromSp	sp-matrix.h	/^  void CopyFromSp(const SpMatrix<Real> &other) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Eig	qr.cc	/^void SpMatrix<Real>::Eig(VectorBase<Real> *s, MatrixBase<Real> *P) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Exp	sp-matrix.cc	/^void SpMatrix<Real>::Exp() {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::FrobeniusNorm	sp-matrix.cc	/^Real SpMatrix<Real>::FrobeniusNorm() const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Invert	sp-matrix.cc	/^void SpMatrix<Real>::Invert(Real *logdet, Real *det_sign, bool need_inverse) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::InvertDouble	sp-matrix.cc	/^void SpMatrix<Real>::InvertDouble(Real *logdet, Real *det_sign,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::IsDiagonal	sp-matrix.cc	/^bool SpMatrix<Real>::IsDiagonal(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::IsPosDef	sp-matrix.cc	/^bool SpMatrix<Real>::IsPosDef() const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::IsTridiagonal	sp-matrix.cc	/^bool SpMatrix<Real>::IsTridiagonal(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::IsUnit	sp-matrix.cc	/^bool SpMatrix<Real>::IsUnit(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::IsZero	sp-matrix.cc	/^bool SpMatrix<Real>::IsZero(Real cutoff) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::LimitCond	sp-matrix.cc	/^MatrixIndexT SpMatrix<Real>::LimitCond(Real maxCond, bool invert) {  \/\/ e.g. maxCond = 1.0e+05.$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::LimitCondDouble	sp-matrix.h	/^  MatrixIndexT LimitCondDouble(Real maxCond = 1.0e+5, bool invert = false) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Log	sp-matrix.cc	/^void SpMatrix<Real>::Log() {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::LogDet	sp-matrix.cc	/^Real SpMatrix<Real>::LogDet(Real *det_sign) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::LogPosDefDet	sp-matrix.cc	/^Real SpMatrix<Real>::LogPosDefDet() const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::MaxAbsEig	sp-matrix.cc	/^Real SpMatrix<Real>::MaxAbsEig() const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::PrintEigs	sp-matrix.h	/^  void PrintEigs(const char *name) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Qr	qr.cc	/^void SpMatrix<Real>::Qr(MatrixBase<Real> *Q) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Resize	sp-matrix.h	/^  inline void Resize(MatrixIndexT nRows, MatrixResizeType resize_type = kSetZero) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::SpMatrix	sp-matrix.h	/^  SpMatrix(): PackedMatrix<Real>() {}$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::SpMatrix	sp-matrix.h	/^  SpMatrix(const SpMatrix<Real> &orig)$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::SpMatrix	sp-matrix.h	/^  explicit SpMatrix(MatrixIndexT r, MatrixResizeType resize_type = kSetZero)$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::SpMatrix	sp-matrix.h	/^  explicit SpMatrix(const MatrixBase<Real> & orig,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::SpMatrix	sp-matrix.h	/^  explicit SpMatrix(const SpMatrix<OtherReal> &orig)$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Swap	sp-matrix.cc	/^void SpMatrix<Real>::Swap(SpMatrix<Real> *other) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::SymPosSemiDefEig	sp-matrix.cc	/^void SpMatrix<Real>::SymPosSemiDefEig(VectorBase<Real> *s,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::TopEigs	qr.cc	/^void SpMatrix<Real>::TopEigs(VectorBase<Real> *s, MatrixBase<Real> *P,$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Trace	sp-matrix.cc	/^Real SpMatrix<Real>::Trace() const {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::Tridiagonalize	qr.cc	/^void SpMatrix<Real>::Tridiagonalize(MatrixBase<Real> *Q) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::operator ()	sp-matrix.h	/^  inline Real &operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::SpMatrix
kaldi::SpMatrix::operator ()	sp-matrix.h	/^  inline Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::SpMatrix
kaldi::SplitRadixComplexFft	srfft.h	/^class SplitRadixComplexFft {$/;"	c	namespace:kaldi
kaldi::SplitRadixComplexFft::BitReversePermute	srfft.cc	/^void SplitRadixComplexFft<Real>::BitReversePermute(Real *x, MatrixIndexT logm) const {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::Compute	srfft.cc	/^void SplitRadixComplexFft<Real>::Compute(Real *x, bool forward) {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::Compute	srfft.cc	/^void SplitRadixComplexFft<Real>::Compute(Real *xr, Real *xi, bool forward) const {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::ComputeRecursive	srfft.cc	/^void SplitRadixComplexFft<Real>::ComputeRecursive(Real *xr, Real *xi, MatrixIndexT logm) const {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::ComputeTables	srfft.cc	/^void SplitRadixComplexFft<Real>::ComputeTables() {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::Integer	srfft.h	/^  typedef MatrixIndexT Integer;$/;"	t	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::N_	srfft.h	/^  Integer N_;$/;"	m	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::SplitRadixComplexFft	srfft.cc	/^SplitRadixComplexFft<Real>::SplitRadixComplexFft(MatrixIndexT N) {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::brseed	srfft.h	/^  Integer *brseed;$/;"	m	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::logm_	srfft.h	/^  Integer logm_;  \/\/ log(N) [a slight mismatch in notation which we have not$/;"	m	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::tab	srfft.h	/^  Real **tab;       \/\/ Tables of butterfly coefficients.$/;"	m	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::temp_buffer	srfft.h	/^  Real *temp_buffer;  \/\/ Allocated only if someone calls Compute with only$/;"	m	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixComplexFft::~SplitRadixComplexFft	srfft.cc	/^SplitRadixComplexFft<Real>::~SplitRadixComplexFft() {$/;"	f	class:kaldi::SplitRadixComplexFft
kaldi::SplitRadixRealFft	srfft.h	/^class SplitRadixRealFft: private SplitRadixComplexFft<Real> {$/;"	c	namespace:kaldi
kaldi::SplitRadixRealFft::Compute	srfft.cc	/^void SplitRadixRealFft<Real>::Compute(Real *data, bool forward) {$/;"	f	class:kaldi::SplitRadixRealFft
kaldi::SplitRadixRealFft::N_	srfft.h	/^  int N_;$/;"	m	class:kaldi::SplitRadixRealFft
kaldi::SplitRadixRealFft::SplitRadixRealFft	srfft.h	/^  SplitRadixRealFft(MatrixIndexT N):  \/\/ will fail unless N>=4 and N is a power of 2.$/;"	f	class:kaldi::SplitRadixRealFft
kaldi::SubMatrix	kaldi-matrix.h	/^class SubMatrix : public MatrixBase<Real> {$/;"	c	namespace:kaldi
kaldi::SubMatrix::SubMatrix	kaldi-matrix.cc	/^SubMatrix<Real>::SubMatrix(Real *data,$/;"	f	class:kaldi::SubMatrix
kaldi::SubMatrix::SubMatrix	kaldi-matrix.cc	/^SubMatrix<Real>::SubMatrix(const MatrixBase<Real> &M,$/;"	f	class:kaldi::SubMatrix
kaldi::SubMatrix::SubMatrix	kaldi-matrix.h	/^  SubMatrix<Real> (const SubMatrix &other):$/;"	f	class:kaldi::SubMatrix
kaldi::SubMatrix::~SubMatrix	kaldi-matrix.h	/^  ~SubMatrix<Real>() {}$/;"	f	class:kaldi::SubMatrix
kaldi::SubVector	kaldi-vector.h	/^class SubVector : public VectorBase<Real> {$/;"	c	namespace:kaldi
kaldi::SubVector::SubVector	kaldi-vector.h	/^  SubVector(Real *data, MatrixIndexT length) : VectorBase<Real> () {$/;"	f	class:kaldi::SubVector
kaldi::SubVector::SubVector	kaldi-vector.h	/^  SubVector(const MatrixBase<Real> &matrix, MatrixIndexT row) {$/;"	f	class:kaldi::SubVector
kaldi::SubVector::SubVector	kaldi-vector.h	/^  SubVector(const PackedMatrix<Real> &M) {$/;"	f	class:kaldi::SubVector
kaldi::SubVector::SubVector	kaldi-vector.h	/^  SubVector(const SubVector &other) : VectorBase<Real> () {$/;"	f	class:kaldi::SubVector
kaldi::SubVector::SubVector	kaldi-vector.h	/^  SubVector(const VectorBase<Real> &t, const MatrixIndexT origin,$/;"	f	class:kaldi::SubVector
kaldi::SubVector::operator =	kaldi-vector.h	/^  SubVector & operator = (const SubVector &other) {}$/;"	f	class:kaldi::SubVector
kaldi::SubVector::~SubVector	kaldi-vector.h	/^  ~SubVector() {}  \/\/\/< Destructor (does nothing; no pointers are owned here).$/;"	f	class:kaldi::SubVector
kaldi::Tensor	kaldi-tensor.h	/^class Tensor {  $/;"	c	namespace:kaldi
kaldi::Tensor::AddTensorTensor	kaldi-tensor.cc	/^void Tensor<Real>::AddTensorTensor(BaseFloat alpha,$/;"	f	class:kaldi::Tensor
kaldi::Tensor::CheckAndFixDims	kaldi-tensor.cc	/^int32 Tensor<Real>::CheckAndFixDims() {$/;"	f	class:kaldi::Tensor
kaldi::Tensor::Data	kaldi-tensor.h	/^  Real *Data() { return data_; }$/;"	f	class:kaldi::Tensor
kaldi::Tensor::Dim	kaldi-tensor.cc	/^int32 Tensor<Real>::Dim(int32 index) const {$/;"	f	class:kaldi::Tensor
kaldi::Tensor::DimInfo	kaldi-tensor.h	/^  struct DimInfo {$/;"	s	class:kaldi::Tensor
kaldi::Tensor::DimInfo::dim	kaldi-tensor.h	/^    int32 dim;$/;"	m	struct:kaldi::Tensor::DimInfo
kaldi::Tensor::DimInfo::stride	kaldi-tensor.h	/^    int32 stride;$/;"	m	struct:kaldi::Tensor::DimInfo
kaldi::Tensor::Scale	kaldi-tensor.cc	/^void Tensor<Real>::Scale(BaseFloat alpha) {$/;"	f	class:kaldi::Tensor
kaldi::Tensor::Stride	kaldi-tensor.cc	/^int32 Tensor<Real>::Stride(int32 index) const {$/;"	f	class:kaldi::Tensor
kaldi::Tensor::Tensor	kaldi-tensor.cc	/^Tensor<Real>::Tensor(const MatrixBase<Real> &mat,$/;"	f	class:kaldi::Tensor
kaldi::Tensor::Tensor	kaldi-tensor.cc	/^Tensor<Real>::Tensor(const VectorBase<Real> &vec,$/;"	f	class:kaldi::Tensor
kaldi::Tensor::Tensor	kaldi-tensor.h	/^  Tensor() { } \/\/ Disallow default constructor.$/;"	f	class:kaldi::Tensor
kaldi::Tensor::data_	kaldi-tensor.h	/^  Real *data_;  \/\/ not owned here.$/;"	m	class:kaldi::Tensor
kaldi::Tensor::dims_	kaldi-tensor.h	/^  DimInfo dims_[5];$/;"	m	class:kaldi::Tensor
kaldi::Tensor::operator ()	kaldi-tensor-inl.h	/^Real Tensor<Real>::operator()(int32 d0, int32 d1, int32 d2, int32 d3, int32 d4) const {$/;"	f	class:kaldi::Tensor
kaldi::Tensor::operator ()	kaldi-tensor-inl.h	/^Real& Tensor<Real>::operator() (int32 d0, int32 d1, int32 d2, int32 d3, int32 d4) {$/;"	f	class:kaldi::Tensor
kaldi::TpMatrix	tp-matrix.h	/^class TpMatrix : public PackedMatrix<Real> {$/;"	c	namespace:kaldi
kaldi::TpMatrix::AddTp	tp-matrix.h	/^  void AddTp(const Real alpha, const TpMatrix<Real> &M) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::Cholesky	tp-matrix.cc	/^void TpMatrix<Real>::Cholesky(const SpMatrix<Real> &orig) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::CopyFromMat	tp-matrix.cc	/^void TpMatrix<Real>::CopyFromMat(const MatrixBase<Real> &M,$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::CopyFromTp	tp-matrix.h	/^  template<typename OtherReal> void CopyFromTp(const TpMatrix<OtherReal> &other) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::CopyFromTp	tp-matrix.h	/^  void CopyFromTp(const TpMatrix<Real> &other) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::Determinant	tp-matrix.cc	/^Real TpMatrix<Real>::Determinant() {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::Invert	tp-matrix.cc	/^void TpMatrix<Real>::Invert() {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::InvertDouble	tp-matrix.h	/^  void InvertDouble() {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::Resize	tp-matrix.h	/^  void Resize(MatrixIndexT nRows, MatrixResizeType resize_type = kSetZero) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::Swap	tp-matrix.cc	/^void TpMatrix<Real>::Swap(TpMatrix<Real> *other) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::TpMatrix	tp-matrix.h	/^  TpMatrix() : PackedMatrix<Real>() {}$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::TpMatrix	tp-matrix.h	/^  TpMatrix(const TpMatrix<Real>& Orig) : PackedMatrix<Real>(Orig) {}$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::TpMatrix	tp-matrix.h	/^  explicit TpMatrix(MatrixIndexT r, MatrixResizeType resize_type = kSetZero)$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::TpMatrix	tp-matrix.h	/^  template<typename OtherReal> explicit TpMatrix(const TpMatrix<OtherReal>& Orig)$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::operator ()	tp-matrix.h	/^  Real &operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::TpMatrix
kaldi::TpMatrix::operator ()	tp-matrix.h	/^  Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::TpMatrix
kaldi::TraceMat	kaldi-matrix.h	/^double TraceMat(const MatrixBase<Real> &A) { return A.Trace(); }$/;"	f	namespace:kaldi
kaldi::TraceMatMat	kaldi-matrix.cc	/^Real TraceMatMat(const MatrixBase<Real> &A,$/;"	f	namespace:kaldi
kaldi::TraceMatMatMat	kaldi-matrix.cc	/^Real TraceMatMatMat(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
kaldi::TraceMatMatMatMat	kaldi-matrix.cc	/^Real TraceMatMatMatMat(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
kaldi::TraceMatSpMat	sp-matrix.cc	/^Real TraceMatSpMat(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
kaldi::TraceMatSpMatSp	sp-matrix.cc	/^Real TraceMatSpMatSp(const MatrixBase<Real> &A, MatrixTransposeType transA,$/;"	f	namespace:kaldi
kaldi::TraceSpMat	sp-matrix.cc	/^Real TraceSpMat(const SpMatrix<Real> &A, const MatrixBase<Real> &B) {$/;"	f	namespace:kaldi
kaldi::TraceSpSp	sp-matrix.cc	/^Real TraceSpSp(const SpMatrix<Real> &A, const SpMatrix<OtherReal> &B) {$/;"	f	namespace:kaldi
kaldi::TraceSpSp	sp-matrix.cc	/^double TraceSpSp(const SpMatrix<double> &A, const SpMatrix<double> &B) {$/;"	f	namespace:kaldi
kaldi::TraceSpSp	sp-matrix.cc	/^float TraceSpSp(const SpMatrix<float> &A, const SpMatrix<float> &B) {$/;"	f	namespace:kaldi
kaldi::TraceSpSpLower	sp-matrix.cc	/^Real TraceSpSpLower(const SpMatrix<Real> &A, const SpMatrix<Real> &B) {$/;"	f	namespace:kaldi
kaldi::UnitTestAddDiagMat2	matrix-lib-test.cc	/^static void UnitTestAddDiagMat2() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddDiagMatMat	matrix-lib-test.cc	/^static void UnitTestAddDiagMatMat() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddDiagVecMat	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddDiagVecMat() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddMat2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMat2() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddMat2Sp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMat2Sp() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddMatSelf	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMatSelf() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddMatSmat	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddMatSmat() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddOuterProductPlusMinus	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddOuterProductPlusMinus() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddSp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddSp() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddToDiag	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddToDiag() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddToDiagMatrix	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddToDiagMatrix() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddVec2Sp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVec2Sp() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddVecCross	matrix-lib-test.cc	/^void UnitTestAddVecCross() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddVecToCols	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVecToCols() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddVecToRows	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVecToRows() {$/;"	f	namespace:kaldi
kaldi::UnitTestAddVecVec	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAddVecVec() {$/;"	f	namespace:kaldi
kaldi::UnitTestAxpy	matrix-lib-test.cc	/^template<typename Real> static void UnitTestAxpy() {$/;"	f	namespace:kaldi
kaldi::UnitTestComplexFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestComplexFft() {$/;"	f	namespace:kaldi
kaldi::UnitTestComplexFft2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestComplexFft2() {$/;"	f	namespace:kaldi
kaldi::UnitTestComplexFt	matrix-lib-test.cc	/^template<typename Real> static void UnitTestComplexFt() {$/;"	f	namespace:kaldi
kaldi::UnitTestComplexPower	matrix-lib-test.cc	/^void UnitTestComplexPower() {$/;"	f	namespace:kaldi
kaldi::UnitTestCompressedMatrix	matrix-lib-test.cc	/^template<typename Real> static void UnitTestCompressedMatrix() {$/;"	f	namespace:kaldi
kaldi::UnitTestCopyCols	matrix-lib-test.cc	/^static void UnitTestCopyCols() {$/;"	f	namespace:kaldi
kaldi::UnitTestCopyRows	matrix-lib-test.cc	/^static void UnitTestCopyRows() {$/;"	f	namespace:kaldi
kaldi::UnitTestCopyRowsAndCols	matrix-lib-test.cc	/^template<typename Real> static void UnitTestCopyRowsAndCols() {$/;"	f	namespace:kaldi
kaldi::UnitTestCopySp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestCopySp() {$/;"	f	namespace:kaldi
kaldi::UnitTestDct	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDct() {$/;"	f	namespace:kaldi
kaldi::UnitTestDeterminant	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDeterminant() {  \/\/ also tests matrix axpy and IsZero() and TraceOfProduct{, T}$/;"	f	namespace:kaldi
kaldi::UnitTestDeterminantSign	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDeterminantSign() {$/;"	f	namespace:kaldi
kaldi::UnitTestDotprod	matrix-lib-test.cc	/^template<typename Real> static void UnitTestDotprod() {$/;"	f	namespace:kaldi
kaldi::UnitTestEig	matrix-lib-test.cc	/^template<typename Real> static void UnitTestEig() {$/;"	f	namespace:kaldi
kaldi::UnitTestEigSp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestEigSp() {$/;"	f	namespace:kaldi
kaldi::UnitTestEigSymmetric	matrix-lib-test.cc	/^template<typename Real> static void UnitTestEigSymmetric() {$/;"	f	namespace:kaldi
kaldi::UnitTestFloorCeiling	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestFloorCeiling() {$/;"	f	namespace:kaldi
kaldi::UnitTestFloorChol	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestFloorChol() {$/;"	f	namespace:kaldi
kaldi::UnitTestFloorUnit	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestFloorUnit() {$/;"	f	namespace:kaldi
kaldi::UnitTestGpsr	kaldi-gpsr-test.cc	/^template<typename Real> static void UnitTestGpsr() {$/;"	f	namespace:kaldi
kaldi::UnitTestHeaviside	matrix-lib-test.cc	/^template<typename Real> static void UnitTestHeaviside() {$/;"	f	namespace:kaldi
kaldi::UnitTestHtkIo	matrix-lib-test.cc	/^template<typename Real> static void UnitTestHtkIo() {$/;"	f	namespace:kaldi
kaldi::UnitTestInnerProd	matrix-lib-test.cc	/^template<typename Real> static void UnitTestInnerProd() {$/;"	f	namespace:kaldi
kaldi::UnitTestInverse	matrix-lib-test.cc	/^template<typename Real> static void UnitTestInverse() {$/;"	f	namespace:kaldi
kaldi::UnitTestIo	matrix-lib-test.cc	/^template<typename Real> static void UnitTestIo() {$/;"	f	namespace:kaldi
kaldi::UnitTestIoCross	matrix-lib-test.cc	/^template<typename Real> static void UnitTestIoCross() {  \/\/ across types.$/;"	f	namespace:kaldi
kaldi::UnitTestLbfgs	matrix-lib-test.cc	/^template<typename Real> static void UnitTestLbfgs() {$/;"	f	namespace:kaldi
kaldi::UnitTestLimitCond	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestLimitCond() {$/;"	f	namespace:kaldi
kaldi::UnitTestLimitCondInvert	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestLimitCondInvert() {$/;"	f	namespace:kaldi
kaldi::UnitTestMat2Vec	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestMat2Vec() {$/;"	f	namespace:kaldi
kaldi::UnitTestMatrixExponential	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMatrixExponential() {$/;"	f	namespace:kaldi
kaldi::UnitTestMatrixExponentialBackprop	matrix-lib-test.cc	/^static void UnitTestMatrixExponentialBackprop() {$/;"	f	namespace:kaldi
kaldi::UnitTestMax2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMax2() {$/;"	f	namespace:kaldi
kaldi::UnitTestMaxAbsEig	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMaxAbsEig() {$/;"	f	namespace:kaldi
kaldi::UnitTestMaxMin	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMaxMin() {$/;"	f	namespace:kaldi
kaldi::UnitTestMmul	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMmul() {$/;"	f	namespace:kaldi
kaldi::UnitTestMmulSym	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMmulSym() {$/;"	f	namespace:kaldi
kaldi::UnitTestMul	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMul() {$/;"	f	namespace:kaldi
kaldi::UnitTestMulElements	matrix-lib-test.cc	/^template<typename Real> static void UnitTestMulElements() {$/;"	f	namespace:kaldi
kaldi::UnitTestNonsymmetricPower	matrix-lib-test.cc	/^void UnitTestNonsymmetricPower() {$/;"	f	namespace:kaldi
kaldi::UnitTestNorm	matrix-lib-test.cc	/^static void UnitTestNorm() {  \/\/ test some simple norm properties: scaling.  also ApproxEqual test.$/;"	f	namespace:kaldi
kaldi::UnitTestOrthogonalizeRows	matrix-lib-test.cc	/^static void UnitTestOrthogonalizeRows() {$/;"	f	namespace:kaldi
kaldi::UnitTestPca	matrix-lib-test.cc	/^static void UnitTestPca(bool full_test) {$/;"	f	namespace:kaldi
kaldi::UnitTestPca2	matrix-lib-test.cc	/^static void UnitTestPca2(bool full_test) {$/;"	f	namespace:kaldi
kaldi::UnitTestPower	matrix-lib-test.cc	/^template<typename Real> static void UnitTestPower() {$/;"	f	namespace:kaldi
kaldi::UnitTestRandCategorical	matrix-lib-test.cc	/^static void UnitTestRandCategorical() {$/;"	f	namespace:kaldi
kaldi::UnitTestRange	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRange() {  \/\/ Testing SubMatrix class.$/;"	f	namespace:kaldi
kaldi::UnitTestRankNUpdate	matrix-lib-test.cc	/^static void UnitTestRankNUpdate() {$/;"	f	namespace:kaldi
kaldi::UnitTestRealFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRealFft() {$/;"	f	namespace:kaldi
kaldi::UnitTestRealFftSpeed	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRealFftSpeed() {$/;"	f	namespace:kaldi
kaldi::UnitTestRemoveRow	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRemoveRow() {$/;"	f	namespace:kaldi
kaldi::UnitTestReplaceValue	matrix-lib-test.cc	/^static void UnitTestReplaceValue(){$/;"	f	namespace:kaldi
kaldi::UnitTestResize	matrix-lib-test.cc	/^static void UnitTestResize() {$/;"	f	namespace:kaldi
kaldi::UnitTestRow	matrix-lib-test.cc	/^template<typename Real> static void UnitTestRow() {$/;"	f	namespace:kaldi
kaldi::UnitTestScale	matrix-lib-test.cc	/^template<typename Real> static void UnitTestScale() {$/;"	f	namespace:kaldi
kaldi::UnitTestScaleDiag	matrix-lib-test.cc	/^template<typename Real> static void UnitTestScaleDiag() {$/;"	f	namespace:kaldi
kaldi::UnitTestSetDiag	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSetDiag() {$/;"	f	namespace:kaldi
kaldi::UnitTestSetRandUniform	matrix-lib-test.cc	/^static void UnitTestSetRandUniform() {$/;"	f	namespace:kaldi
kaldi::UnitTestSetRandn	matrix-lib-test.cc	/^static void UnitTestSetRandn() {$/;"	f	namespace:kaldi
kaldi::UnitTestSger	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSger() {$/;"	f	namespace:kaldi
kaldi::UnitTestSherman	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSherman() {$/;"	f	namespace:kaldi
kaldi::UnitTestSigmoid	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSigmoid() {$/;"	f	namespace:kaldi
kaldi::UnitTestSimple	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSimple() {$/;"	f	namespace:kaldi
kaldi::UnitTestSimpleForMat	matrix-lib-test.cc	/^static void UnitTestSimpleForMat() {  \/\/ test some simple operates on all kinds of matrix$/;"	f	namespace:kaldi
kaldi::UnitTestSimpleForVec	matrix-lib-test.cc	/^static void UnitTestSimpleForVec() {  \/\/ testing some simple operaters on vector$/;"	f	namespace:kaldi
kaldi::UnitTestSoftHinge	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSoftHinge() {$/;"	f	namespace:kaldi
kaldi::UnitTestSolve	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSolve() {$/;"	f	namespace:kaldi
kaldi::UnitTestSpAddVec	matrix-lib-test.cc	/^static void UnitTestSpAddVec() {$/;"	f	namespace:kaldi
kaldi::UnitTestSpAddVecVec	matrix-lib-test.cc	/^static void UnitTestSpAddVecVec() {$/;"	f	namespace:kaldi
kaldi::UnitTestSpInvert	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestSpInvert() {$/;"	f	namespace:kaldi
kaldi::UnitTestSpLogExp	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSpLogExp() {$/;"	f	namespace:kaldi
kaldi::UnitTestSpVec	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSpVec() {$/;"	f	namespace:kaldi
kaldi::UnitTestSpliceRows	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSpliceRows() {$/;"	f	namespace:kaldi
kaldi::UnitTestSplitRadixComplexFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixComplexFft() {$/;"	f	namespace:kaldi
kaldi::UnitTestSplitRadixComplexFft2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixComplexFft2() {$/;"	f	namespace:kaldi
kaldi::UnitTestSplitRadixRealFft	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixRealFft() {$/;"	f	namespace:kaldi
kaldi::UnitTestSplitRadixRealFftSpeed	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSplitRadixRealFftSpeed() {$/;"	f	namespace:kaldi
kaldi::UnitTestSubvector	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSubvector() {$/;"	f	namespace:kaldi
kaldi::UnitTestSvd	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvd() {$/;"	f	namespace:kaldi
kaldi::UnitTestSvdBad	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdBad() {$/;"	f	namespace:kaldi
kaldi::UnitTestSvdJustvec	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdJustvec() {  \/\/ Making sure gives same answer if we get just the vector, not the eigs.$/;"	f	namespace:kaldi
kaldi::UnitTestSvdNodestroy	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdNodestroy() {$/;"	f	namespace:kaldi
kaldi::UnitTestSvdSpeed	matrix-lib-test.cc	/^static void UnitTestSvdSpeed() {$/;"	f	namespace:kaldi
kaldi::UnitTestSvdZero	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSvdZero() {$/;"	f	namespace:kaldi
kaldi::UnitTestSymAddMat2	matrix-lib-test.cc	/^template<typename Real> static void UnitTestSymAddMat2() {$/;"	f	namespace:kaldi
kaldi::UnitTestTanh	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestTanh() {$/;"	f	namespace:kaldi
kaldi::UnitTestTopEigs	matrix-lib-test.cc	/^static void UnitTestTopEigs() {$/;"	f	namespace:kaldi
kaldi::UnitTestTp2	matrix-lib-test.cc	/^static void UnitTestTp2() {$/;"	f	namespace:kaldi
kaldi::UnitTestTp2Sp	matrix-lib-test.cc	/^static void UnitTestTp2Sp() {$/;"	f	namespace:kaldi
kaldi::UnitTestTpInvert	matrix-lib-test.cc	/^template<typename Real> static void  UnitTestTpInvert() {$/;"	f	namespace:kaldi
kaldi::UnitTestTrace	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTrace() {$/;"	f	namespace:kaldi
kaldi::UnitTestTraceProduct	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTraceProduct() {$/;"	f	namespace:kaldi
kaldi::UnitTestTraceSpSpLower	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTraceSpSpLower() {$/;"	f	namespace:kaldi
kaldi::UnitTestTranspose	matrix-lib-test.cc	/^template<typename Real> static void UnitTestTranspose() {$/;"	f	namespace:kaldi
kaldi::UnitTestTransposeScatter	matrix-lib-test.cc	/^static void UnitTestTransposeScatter() {$/;"	f	namespace:kaldi
kaldi::UnitTestTridiag	matrix-lib-test.cc	/^static void UnitTestTridiag() {$/;"	f	namespace:kaldi
kaldi::UnitTestTridiagonalize	matrix-lib-test.cc	/^static void UnitTestTridiagonalize() {$/;"	f	namespace:kaldi
kaldi::UnitTestTridiagonalizeAndQr	matrix-lib-test.cc	/^static void UnitTestTridiagonalizeAndQr() {$/;"	f	namespace:kaldi
kaldi::UnitTestVecmul	matrix-lib-test.cc	/^template<typename Real> static void UnitTestVecmul() {$/;"	f	namespace:kaldi
kaldi::UnitTestVectorMax	matrix-lib-test.cc	/^static void UnitTestVectorMax() {$/;"	f	namespace:kaldi
kaldi::UnitTestVectorMin	matrix-lib-test.cc	/^static void UnitTestVectorMin() {$/;"	f	namespace:kaldi
kaldi::UnsignedMatrixIndexT	matrix-common.h	/^typedef uint32 UnsignedMatrixIndexT;$/;"	t	namespace:kaldi
kaldi::VecMatVec	kaldi-vector.cc	/^Real VecMatVec(const VectorBase<Real> &v1, const MatrixBase<Real> &M,$/;"	f	namespace:kaldi
kaldi::VecSpVec	sp-matrix.cc	/^Real VecSpVec(const VectorBase<Real> &v1, const SpMatrix<Real> &M,$/;"	f	namespace:kaldi
kaldi::VecVec	kaldi-vector.cc	/^Real VecVec(const VectorBase<Real> &a,$/;"	f	namespace:kaldi
kaldi::VecVec	kaldi-vector.cc	/^Real VecVec(const VectorBase<Real> &ra,$/;"	f	namespace:kaldi
kaldi::Vector	kaldi-vector.h	/^class Vector: public VectorBase<Real> {$/;"	c	namespace:kaldi
kaldi::Vector::Destroy	kaldi-vector.cc	/^void Vector<Real>::Destroy() {$/;"	f	class:kaldi::Vector
kaldi::Vector::Init	kaldi-vector.cc	/^inline void Vector<Real>::Init(const MatrixIndexT dim) {$/;"	f	class:kaldi::Vector
kaldi::Vector::Read	kaldi-vector.cc	/^void Vector<Real>::Read(std::istream & is,  bool binary, bool add) {$/;"	f	class:kaldi::Vector
kaldi::Vector::RemoveElement	kaldi-vector.cc	/^void Vector<Real>::RemoveElement(MatrixIndexT i) {$/;"	f	class:kaldi::Vector
kaldi::Vector::Resize	kaldi-vector.cc	/^void Vector<Real>::Resize(const MatrixIndexT dim, MatrixResizeType resize_type) {$/;"	f	class:kaldi::Vector
kaldi::Vector::Swap	kaldi-vector.cc	/^void Vector<Real>::Swap(Vector<Real> *other) {$/;"	f	class:kaldi::Vector
kaldi::Vector::Vector	kaldi-vector.h	/^  Vector(): VectorBase<Real>() {}$/;"	f	class:kaldi::Vector
kaldi::Vector::Vector	kaldi-vector.h	/^  Vector(const Vector<Real> &v) : VectorBase<Real>()  { \/\/  (cannot be explicit)$/;"	f	class:kaldi::Vector
kaldi::Vector::Vector	kaldi-vector.h	/^  explicit Vector(const MatrixIndexT s,$/;"	f	class:kaldi::Vector
kaldi::Vector::Vector	kaldi-vector.h	/^  explicit Vector(const VectorBase<OtherReal> &v): VectorBase<Real>() {$/;"	f	class:kaldi::Vector
kaldi::Vector::Vector	kaldi-vector.h	/^  explicit Vector(const VectorBase<Real> &v) : VectorBase<Real>() {$/;"	f	class:kaldi::Vector
kaldi::Vector::operator =	kaldi-vector.h	/^  Vector<Real> &operator = (const Vector<Real> &other) {$/;"	f	class:kaldi::Vector
kaldi::Vector::operator =	kaldi-vector.h	/^  Vector<Real> &operator = (const VectorBase<Real> &other) {$/;"	f	class:kaldi::Vector
kaldi::Vector::~Vector	kaldi-vector.h	/^  ~Vector() { Destroy(); }$/;"	f	class:kaldi::Vector
kaldi::VectorBase	kaldi-vector.h	/^class VectorBase {$/;"	c	namespace:kaldi
kaldi::VectorBase::Add	kaldi-vector.cc	/^void VectorBase<Real>::Add(Real c) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddColSumMat	kaldi-vector.cc	/^void VectorBase<Real>::AddColSumMat(Real alpha, const MatrixBase<Real> &M, Real beta) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddDiagMat2	kaldi-vector.cc	/^void VectorBase<Real>::AddDiagMat2($/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddDiagMatMat	kaldi-vector.cc	/^void VectorBase<Real>::AddDiagMatMat($/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddMatSvec	kaldi-vector.cc	/^void VectorBase<Real>::AddMatSvec(const Real alpha,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddMatVec	kaldi-vector.cc	/^void VectorBase<Real>::AddMatVec(const Real alpha,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddRowSumMat	kaldi-vector.cc	/^void VectorBase<Real>::AddRowSumMat(Real alpha, const MatrixBase<Real> &M, Real beta) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddSpVec	kaldi-vector.cc	/^void VectorBase<Real>::AddSpVec(const Real alpha,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddTpVec	kaldi-vector.cc	/^void VectorBase<Real>::AddTpVec(const Real alpha, const TpMatrix<Real> &M,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVec	kaldi-vector.cc	/^void VectorBase<Real>::AddVec(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVec	kaldi-vector.cc	/^void VectorBase<double>::AddVec(const double alpha,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVec	kaldi-vector.cc	/^void VectorBase<float>::AddVec(const float alpha,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVec2	kaldi-vector.cc	/^void VectorBase<Real>::AddVec2(const Real alpha, const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVec2	kaldi-vector.cc	/^void VectorBase<Real>::AddVec2(const Real alpha, const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVecDivVec	kaldi-vector.cc	/^void VectorBase<Real>::AddVecDivVec(Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::AddVecVec	kaldi-vector.cc	/^void VectorBase<Real>::AddVecVec(Real alpha, const VectorBase<Real> &v,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyAbs	kaldi-vector.cc	/^void VectorBase<Real>::ApplyAbs() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyCeiling	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::ApplyCeiling(Real ceil_val) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyExp	kaldi-vector.cc	/^void VectorBase<Real>::ApplyExp() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyFloor	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::ApplyFloor(Real floor_val) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyFloor	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::ApplyFloor(const VectorBase<Real> &floor_vec) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyLog	kaldi-vector.cc	/^void VectorBase<Real>::ApplyLog() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyLogAndCopy	kaldi-vector.cc	/^void VectorBase<Real>::ApplyLogAndCopy(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyPow	kaldi-vector.cc	/^void VectorBase<Real>::ApplyPow(Real power) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyPow	kaldi-vector.cc	/^void VectorBase<double>::ApplyPow(double power) { vdPowx(dim_, data_, power, data_); }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplyPow	kaldi-vector.cc	/^void VectorBase<float>::ApplyPow(float power) { vsPowx(dim_, data_, power, data_); }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApplySoftMax	kaldi-vector.cc	/^Real VectorBase<Real>::ApplySoftMax() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ApproxEqual	kaldi-vector.cc	/^bool VectorBase<Real>::ApproxEqual(const VectorBase<Real> &other, float tol) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyColFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyColFromMat(const MatrixBase<OtherReal> &mat, MatrixIndexT col) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyColsFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyColsFromMat(const MatrixBase<Real> &mat) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyDiagFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyDiagFromMat(const MatrixBase<Real> &M) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyDiagFromPacked	kaldi-vector.cc	/^void VectorBase<Real>::CopyDiagFromPacked(const PackedMatrix<Real> &M) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyDiagFromSp	kaldi-vector.h	/^  inline void CopyDiagFromSp(const SpMatrix<Real> &M) { CopyDiagFromPacked(M); }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyDiagFromTp	kaldi-vector.h	/^  inline void CopyDiagFromTp(const TpMatrix<Real> &M) { CopyDiagFromPacked(M); }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyFromPacked	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromPacked(const PackedMatrix<OtherReal>& M) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyFromPtr	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromPtr(const Real *data, MatrixIndexT sz) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyFromVec	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromVec(const VectorBase<OtherReal> &other) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyFromVec	kaldi-vector.cc	/^void VectorBase<Real>::CopyFromVec(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyRowFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowFromMat(const MatrixBase<OtherReal> &mat, MatrixIndexT row) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyRowFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowFromMat(const MatrixBase<Real> &mat, MatrixIndexT row) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyRowFromSp	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowFromSp(const SpMatrix<OtherReal> &sp, MatrixIndexT row) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyRowsFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowsFromMat(const MatrixBase<OtherReal> &mat) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::CopyRowsFromMat	kaldi-vector.cc	/^void VectorBase<Real>::CopyRowsFromMat(const MatrixBase<Real> &mat) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Data	kaldi-vector.h	/^  inline Real* Data() { return data_; }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Data	kaldi-vector.h	/^  inline const Real* Data() const { return data_; }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Dim	kaldi-vector.h	/^  inline MatrixIndexT Dim() const { return dim_; }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::DivElements	kaldi-vector.cc	/^void VectorBase<Real>::DivElements(const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::DivElements	kaldi-vector.cc	/^void VectorBase<Real>::DivElements(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::InvertElements	kaldi-vector.cc	/^void VectorBase<Real>::InvertElements() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::IsZero	kaldi-vector.cc	/^bool VectorBase<Real>::IsZero(Real cutoff) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::LogSumExp	kaldi-vector.cc	/^Real VectorBase<Real>::LogSumExp(Real prune) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Max	kaldi-vector.cc	/^Real VectorBase<Real>::Max() const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Max	kaldi-vector.cc	/^Real VectorBase<Real>::Max(MatrixIndexT *index_out) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Min	kaldi-vector.cc	/^Real VectorBase<Real>::Min() const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Min	kaldi-vector.cc	/^Real VectorBase<Real>::Min(MatrixIndexT *index_out) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::MulElements	kaldi-vector.cc	/^void VectorBase<Real>::MulElements(const VectorBase<OtherReal> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::MulElements	kaldi-vector.cc	/^void VectorBase<Real>::MulElements(const VectorBase<Real> &v) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::MulTp	kaldi-vector.cc	/^void VectorBase<Real>::MulTp(const TpMatrix<Real> &M,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Norm	kaldi-vector.cc	/^Real VectorBase<Real>::Norm(Real p) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::RandCategorical	kaldi-vector.cc	/^MatrixIndexT VectorBase<Real>::RandCategorical() const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Range	kaldi-vector.h	/^  SubVector<Real> Range(const MatrixIndexT o, const MatrixIndexT l) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Range	kaldi-vector.h	/^  const SubVector<Real> Range(const MatrixIndexT o,$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Read	kaldi-vector.cc	/^void VectorBase<Real>::Read(std::istream & is,  bool binary, bool add) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::ReplaceValue	kaldi-vector.cc	/^void VectorBase<Real>::ReplaceValue(Real orig, Real changed) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Scale	kaldi-vector.cc	/^void VectorBase<Real>::Scale(Real alpha) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Set	kaldi-vector.cc	/^void VectorBase<Real>::Set(Real f) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::SetRandn	kaldi-vector.cc	/^void VectorBase<Real>::SetRandn() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::SetZero	kaldi-vector.cc	/^void VectorBase<Real>::SetZero() {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Sigmoid	kaldi-vector.cc	/^void VectorBase<Real>::Sigmoid(const VectorBase<Real> &src) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Sigmoid	kaldi-vector.cc	/^void VectorBase<double>::Sigmoid(const VectorBase<double> &src) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Sigmoid	kaldi-vector.cc	/^void VectorBase<float>::Sigmoid(const VectorBase<float> &src) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::SizeInBytes	kaldi-vector.h	/^  inline MatrixIndexT SizeInBytes() const { return (dim_*sizeof(Real)); }$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Sum	kaldi-vector.cc	/^Real VectorBase<Real>::Sum() const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::SumLog	kaldi-vector.cc	/^Real VectorBase<Real>::SumLog() const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Tanh	kaldi-vector.cc	/^void VectorBase<Real>::Tanh(const VectorBase<Real> &src) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Tanh	kaldi-vector.cc	/^void VectorBase<double>::Tanh(const VectorBase<double> &src) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Tanh	kaldi-vector.cc	/^void VectorBase<float>::Tanh(const VectorBase<float> &src) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::VectorBase	kaldi-vector.h	/^  explicit VectorBase(): data_(NULL), dim_(0) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::Write	kaldi-vector.cc	/^void VectorBase<Real>::Write(std::ostream & os, bool binary) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::data_	kaldi-vector.h	/^  Real* data_;$/;"	m	class:kaldi::VectorBase
kaldi::VectorBase::dim_	kaldi-vector.h	/^  MatrixIndexT dim_;$/;"	m	class:kaldi::VectorBase
kaldi::VectorBase::operator ()	kaldi-vector.h	/^  inline Real & operator() (MatrixIndexT i) {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::operator ()	kaldi-vector.h	/^  inline Real operator() (MatrixIndexT i) const {$/;"	f	class:kaldi::VectorBase
kaldi::VectorBase::~VectorBase	kaldi-vector.h	/^  ~VectorBase() {}$/;"	f	class:kaldi::VectorBase
kaldi::WriteHtk	kaldi-matrix.cc	/^bool WriteHtk(std::ostream &os, const MatrixBase<Real> &M, HtkHeader htk_hdr) \/\/ header may be derived from a previous call to ReadHtk.  Must be in binary mode.$/;"	f	namespace:kaldi
kaldi::WriteSphinx	kaldi-matrix.cc	/^bool WriteSphinx(std::ostream &os, const MatrixBase<Real> &M)$/;"	f	namespace:kaldi
kaldi::Xgemv_sparsevec	cblas-wrappers.h	/^inline void Xgemv_sparsevec(MatrixTransposeType trans, MatrixIndexT num_rows,$/;"	f	namespace:kaldi
kaldi::approx_equal	matrix-lib-test.cc	/^static bool approx_equal(Real a, Real b) {$/;"	f	namespace:kaldi
kaldi::cblas_Xasum	cblas-wrappers.h	/^inline double cblas_Xasum(const int N, const double *X, const int incX) {$/;"	f	namespace:kaldi
kaldi::cblas_Xasum	cblas-wrappers.h	/^inline float cblas_Xasum(const int N, const float *X, const int incX) {$/;"	f	namespace:kaldi
kaldi::cblas_Xaxpy	cblas-wrappers.h	/^inline void cblas_Xaxpy(const int N, const double alpha, const double *X,$/;"	f	namespace:kaldi
kaldi::cblas_Xaxpy	cblas-wrappers.h	/^inline void cblas_Xaxpy(const int N, const float alpha, const float *X,$/;"	f	namespace:kaldi
kaldi::cblas_Xcopy	cblas-wrappers.h	/^inline void cblas_Xcopy(const int N, const double *X, const int incX, double *Y,$/;"	f	namespace:kaldi
kaldi::cblas_Xcopy	cblas-wrappers.h	/^inline void cblas_Xcopy(const int N, const float *X, const int incX, float *Y,$/;"	f	namespace:kaldi
kaldi::cblas_Xdot	cblas-wrappers.h	/^inline double cblas_Xdot(const int N, const double *const X,$/;"	f	namespace:kaldi
kaldi::cblas_Xdot	cblas-wrappers.h	/^inline float cblas_Xdot(const int N, const float *const X,$/;"	f	namespace:kaldi
kaldi::cblas_Xgbmv	cblas-wrappers.h	/^inline void cblas_Xgbmv(MatrixTransposeType trans, MatrixIndexT num_rows,$/;"	f	namespace:kaldi
kaldi::cblas_Xgemm	cblas-wrappers.h	/^inline void cblas_Xgemm(const double alpha,$/;"	f	namespace:kaldi
kaldi::cblas_Xgemm	cblas-wrappers.h	/^inline void cblas_Xgemm(const float alpha,$/;"	f	namespace:kaldi
kaldi::cblas_Xgemv	cblas-wrappers.h	/^inline void cblas_Xgemv(MatrixTransposeType trans, MatrixIndexT num_rows,$/;"	f	namespace:kaldi
kaldi::cblas_Xger	cblas-wrappers.h	/^inline void cblas_Xger(MatrixIndexT num_rows, MatrixIndexT num_cols, double alpha,$/;"	f	namespace:kaldi
kaldi::cblas_Xger	cblas-wrappers.h	/^inline void cblas_Xger(MatrixIndexT num_rows, MatrixIndexT num_cols, float alpha,$/;"	f	namespace:kaldi
kaldi::cblas_Xrot	cblas-wrappers.h	/^inline void cblas_Xrot(const int N, double *X, const int incX, double *Y,$/;"	f	namespace:kaldi
kaldi::cblas_Xrot	cblas-wrappers.h	/^inline void cblas_Xrot(const int N, float *X, const int incX, float *Y,$/;"	f	namespace:kaldi
kaldi::cblas_Xsbmv1	cblas-wrappers.h	/^inline void cblas_Xsbmv1($/;"	f	namespace:kaldi
kaldi::cblas_Xscal	cblas-wrappers.h	/^inline void cblas_Xscal(const int N, const double alpha, double *data, $/;"	f	namespace:kaldi
kaldi::cblas_Xscal	cblas-wrappers.h	/^inline void cblas_Xscal(const int N, const float alpha, float *data,$/;"	f	namespace:kaldi
kaldi::cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(MatrixIndexT dim, double alpha, const double *Mdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(MatrixIndexT dim, float alpha, const float *Mdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(const double alpha, const int num_rows, const double *Mdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspmv	cblas-wrappers.h	/^inline void cblas_Xspmv(const float alpha, const int num_rows, const float *Mdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspr	cblas-wrappers.h	/^inline void cblas_Xspr(MatrixIndexT dim, double alpha, const double *Xdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspr	cblas-wrappers.h	/^inline void cblas_Xspr(MatrixIndexT dim, float alpha, const float *Xdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspr2	cblas-wrappers.h	/^inline void cblas_Xspr2(MatrixIndexT dim, double alpha, const double *Xdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xspr2	cblas-wrappers.h	/^inline void cblas_Xspr2(MatrixIndexT dim, float alpha, const float *Xdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xsymm	cblas-wrappers.h	/^inline void cblas_Xsymm(const double alpha,$/;"	f	namespace:kaldi
kaldi::cblas_Xsymm	cblas-wrappers.h	/^inline void cblas_Xsymm(const float alpha,$/;"	f	namespace:kaldi
kaldi::cblas_Xsyrk	cblas-wrappers.h	/^inline void cblas_Xsyrk ($/;"	f	namespace:kaldi
kaldi::cblas_Xsyrk	cblas-wrappers.h	/^inline void cblas_Xsyrk($/;"	f	namespace:kaldi
kaldi::cblas_Xtpmv	cblas-wrappers.h	/^inline void cblas_Xtpmv(MatrixTransposeType trans, const double *Mdata,$/;"	f	namespace:kaldi
kaldi::cblas_Xtpmv	cblas-wrappers.h	/^inline void cblas_Xtpmv(MatrixTransposeType trans, const float *Mdata,$/;"	f	namespace:kaldi
kaldi::clapack_Xgesvd	cblas-wrappers.h	/^inline void clapack_Xgesvd(char *v, char *u, KaldiBlasInt *num_cols,$/;"	f	namespace:kaldi
kaldi::clapack_Xgetrf	cblas-wrappers.h	/^inline void clapack_Xgetrf(MatrixIndexT num_rows, MatrixIndexT num_cols,$/;"	f	namespace:kaldi
kaldi::clapack_Xgetrf2	cblas-wrappers.h	/^inline void clapack_Xgetrf2(KaldiBlasInt *num_rows, KaldiBlasInt *num_cols, $/;"	f	namespace:kaldi
kaldi::clapack_Xgetri	cblas-wrappers.h	/^inline void clapack_Xgetri(MatrixIndexT num_rows, double *Mdata, MatrixIndexT stride,$/;"	f	namespace:kaldi
kaldi::clapack_Xgetri	cblas-wrappers.h	/^inline void clapack_Xgetri(MatrixIndexT num_rows, float *Mdata, MatrixIndexT stride,$/;"	f	namespace:kaldi
kaldi::clapack_Xgetri2	cblas-wrappers.h	/^inline void clapack_Xgetri2(KaldiBlasInt *num_rows, double *Mdata, KaldiBlasInt *stride,$/;"	f	namespace:kaldi
kaldi::clapack_Xgetri2	cblas-wrappers.h	/^inline void clapack_Xgetri2(KaldiBlasInt *num_rows, float *Mdata, KaldiBlasInt *stride,$/;"	f	namespace:kaldi
kaldi::clapack_Xsptrf	cblas-wrappers.h	/^void inline clapack_Xsptrf(KaldiBlasInt *num_rows, double *Mdata,$/;"	f	namespace:kaldi
kaldi::clapack_Xsptrf	cblas-wrappers.h	/^void inline clapack_Xsptrf(KaldiBlasInt *num_rows, float *Mdata,$/;"	f	namespace:kaldi
kaldi::clapack_Xsptri	cblas-wrappers.h	/^void inline clapack_Xsptri(KaldiBlasInt *num_rows, double *Mdata, $/;"	f	namespace:kaldi
kaldi::clapack_Xsptri	cblas-wrappers.h	/^void inline clapack_Xsptri(KaldiBlasInt *num_rows, float *Mdata, $/;"	f	namespace:kaldi
kaldi::clapack_Xtptri	cblas-wrappers.h	/^inline void clapack_Xtptri(KaldiBlasInt *num_rows, double *Mdata, KaldiBlasInt *result) {$/;"	f	namespace:kaldi
kaldi::clapack_Xtptri	cblas-wrappers.h	/^inline void clapack_Xtptri(KaldiBlasInt *num_rows, float *Mdata, KaldiBlasInt *result) {$/;"	f	namespace:kaldi
kaldi::clapack_Xtrtri	cblas-wrappers.h	/^inline int clapack_Xtrtri(int num_rows, double *Mdata, MatrixIndexT stride) {$/;"	f	namespace:kaldi
kaldi::clapack_Xtrtri	cblas-wrappers.h	/^inline int clapack_Xtrtri(int num_rows, float *Mdata, MatrixIndexT stride) {$/;"	f	namespace:kaldi
kaldi::kCopyData	matrix-common.h	/^  kCopyData$/;"	e	enum:kaldi::__anon2
kaldi::kNoTrans	matrix-common.h	/^  kNoTrans = CblasNoTrans$/;"	e	enum:kaldi::__anon1
kaldi::kSetZero	matrix-common.h	/^  kSetZero,$/;"	e	enum:kaldi::__anon2
kaldi::kTakeLower	matrix-common.h	/^  kTakeLower,$/;"	e	enum:kaldi::__anon3
kaldi::kTakeMean	matrix-common.h	/^  kTakeMean,$/;"	e	enum:kaldi::__anon3
kaldi::kTakeMeanAndCheck	matrix-common.h	/^  kTakeMeanAndCheck$/;"	e	enum:kaldi::__anon3
kaldi::kTakeUpper	matrix-common.h	/^  kTakeUpper,$/;"	e	enum:kaldi::__anon3
kaldi::kTrans	matrix-common.h	/^  kTrans    = CblasTrans,$/;"	e	enum:kaldi::__anon1
kaldi::kUndefined	matrix-common.h	/^  kUndefined,$/;"	e	enum:kaldi::__anon2
kaldi::mul_elements	cblas-wrappers.h	/^inline void mul_elements($/;"	f	namespace:kaldi
kaldi::operator <<	kaldi-matrix-inl.h	/^inline std::ostream & operator << (std::ostream & os, const MatrixBase<Real> & M) {$/;"	f	namespace:kaldi
kaldi::operator <<	kaldi-vector-inl.h	/^std::ostream & operator << (std::ostream &os, const VectorBase<Real> &rv) {$/;"	f	namespace:kaldi
kaldi::operator <<	packed-matrix.h	/^std::ostream & operator << (std::ostream & os, const PackedMatrix<Real>& M) {$/;"	f	namespace:kaldi
kaldi::operator >>	kaldi-matrix-inl.h	/^inline std::istream & operator >> (std::istream & is, Matrix<Real> & M) {$/;"	f	namespace:kaldi
kaldi::operator >>	kaldi-matrix-inl.h	/^inline std::istream & operator >> (std::istream & is, MatrixBase<Real> & M) {$/;"	f	namespace:kaldi
kaldi::operator >>	kaldi-vector-inl.h	/^std::istream &operator >> (std::istream &is, Vector<Real> &rv) {$/;"	f	namespace:kaldi
kaldi::operator >>	kaldi-vector-inl.h	/^std::istream &operator >> (std::istream &is, VectorBase<Real> &rv) {$/;"	f	namespace:kaldi
kaldi::operator >>	packed-matrix.h	/^std::istream & operator >> (std::istream &is, PackedMatrix<Real> &M) {$/;"	f	namespace:kaldi
last_failure_type_	optimization.h	/^  enum { kWolfeI, kWolfeII, kNone } last_failure_type_; \/\/ last type of step-search$/;"	m	class:kaldi::OptimizeLbfgs	typeref:enum:kaldi::OptimizeLbfgs::__anon4
logical	kaldi-blas.h	/^    typedef __CLPK_logical          logical;$/;"	t
logm_	srfft.h	/^  Integer logm_;  \/\/ log(N) [a slight mismatch in notation which we have not$/;"	m	class:kaldi::SplitRadixComplexFft
m	optimization.h	/^  int m; \/\/ m is the number of stored vectors L-BFGS keeps.$/;"	m	struct:kaldi::LbfgsOptions
mNSamples	kaldi-matrix.h	/^  int32    mNSamples;$/;"	m	struct:kaldi::HtkHeader
mSampleKind	kaldi-matrix.h	/^  uint16   mSampleKind;$/;"	m	struct:kaldi::HtkHeader
mSamplePeriod	kaldi-matrix.h	/^  int32    mSamplePeriod;$/;"	m	struct:kaldi::HtkHeader
mSampleSize	kaldi-matrix.h	/^  int16    mSampleSize;$/;"	m	struct:kaldi::HtkHeader
main	kaldi-gpsr-test.cc	/^int main() {$/;"	f
main	matrix-lib-test.cc	/^int main() {$/;"	f
max	kaldi-blas.h	102;"	d
max	kaldi-blas.h	78;"	d
max_iters	kaldi-gpsr.h	/^  int32 max_iters;  \/\/\/< Maximum number of iterations$/;"	m	struct:kaldi::GpsrConfig
max_iters_backtrak	kaldi-gpsr.h	/^  int32 max_iters_backtrak;  \/\/\/< Max iterations for backtracking line search$/;"	m	struct:kaldi::GpsrConfig
max_iters_debias	kaldi-gpsr.h	/^  int32 max_iters_debias;  \/\/\/< Maximum number of iterations for debiasing stage$/;"	m	struct:kaldi::GpsrConfig
max_line_search_iters	optimization.h	/^  int max_line_search_iters; \/\/ after this many iters we restart L-BFGS.$/;"	m	struct:kaldi::LbfgsOptions
max_sparsity	kaldi-gpsr.h	/^  double max_sparsity;  \/\/\/< Maximum percentage of dimensions set to 0$/;"	m	struct:kaldi::GpsrConfig
min	kaldi-blas.h	101;"	d
min	kaldi-blas.h	77;"	d
min_value	compressed-matrix.h	/^    float min_value;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
minimize	optimization.h	/^  bool minimize; \/\/ if true, we're minimizing, else maximizing.$/;"	m	struct:kaldi::LbfgsOptions
mul_elements	cblas-wrappers.h	/^inline void mul_elements($/;"	f	namespace:kaldi
n_	jama-eig.h	/^  int n_;  \/\/ matrix dimension.$/;"	m	class:kaldi::EigenvalueDecomposition
name	sp-matrix.h	/^  std::string name;$/;"	m	struct:kaldi::SolverOptions
new_x_	optimization.h	/^  Vector<Real> new_x_; \/\/ the x proposed in the line search.$/;"	m	class:kaldi::OptimizeLbfgs
num_cols	compressed-matrix.h	/^    int32 num_cols;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
num_cols_	kaldi-matrix.h	/^  MatrixIndexT    num_cols_;   \/\/\/ < Number of columns$/;"	m	class:kaldi::MatrixBase
num_rows	compressed-matrix.h	/^    int32 num_rows;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
num_rows_	kaldi-matrix.h	/^  MatrixIndexT    num_rows_;   \/\/\/ < Number of rows$/;"	m	class:kaldi::MatrixBase
num_rows_	packed-matrix.h	/^  MatrixIndexT num_rows_;$/;"	m	class:kaldi::PackedMatrix
num_wolfe_i_failures_	optimization.h	/^  int num_wolfe_i_failures_; \/\/ the num times we decreased step size.$/;"	m	class:kaldi::OptimizeLbfgs
num_wolfe_ii_failures_	optimization.h	/^  int num_wolfe_ii_failures_; \/\/ the num times we increased step size.$/;"	m	class:kaldi::OptimizeLbfgs
operator ()	kaldi-matrix.h	/^  inline Real&  operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::MatrixBase
operator ()	kaldi-matrix.h	/^  inline const Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::MatrixBase
operator ()	kaldi-tensor-inl.h	/^Real Tensor<Real>::operator()(int32 d0, int32 d1, int32 d2, int32 d3, int32 d4) const {$/;"	f	class:kaldi::Tensor
operator ()	kaldi-tensor-inl.h	/^Real& Tensor<Real>::operator() (int32 d0, int32 d1, int32 d2, int32 d3, int32 d4) {$/;"	f	class:kaldi::Tensor
operator ()	kaldi-vector.h	/^  inline Real & operator() (MatrixIndexT i) {$/;"	f	class:kaldi::VectorBase
operator ()	kaldi-vector.h	/^  inline Real operator() (MatrixIndexT i) const {$/;"	f	class:kaldi::VectorBase
operator ()	packed-matrix.h	/^  Real &operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::PackedMatrix
operator ()	packed-matrix.h	/^  Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::PackedMatrix
operator ()	sp-matrix.h	/^  inline Real &operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::SpMatrix
operator ()	sp-matrix.h	/^  inline Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::SpMatrix
operator ()	tp-matrix.h	/^  Real &operator() (MatrixIndexT r, MatrixIndexT c) {$/;"	f	class:kaldi::TpMatrix
operator ()	tp-matrix.h	/^  Real operator() (MatrixIndexT r, MatrixIndexT c) const {$/;"	f	class:kaldi::TpMatrix
operator <<	kaldi-matrix-inl.h	/^inline std::ostream & operator << (std::ostream & os, const MatrixBase<Real> & M) {$/;"	f	namespace:kaldi
operator <<	kaldi-vector-inl.h	/^std::ostream & operator << (std::ostream &os, const VectorBase<Real> &rv) {$/;"	f	namespace:kaldi
operator <<	packed-matrix.h	/^std::ostream & operator << (std::ostream & os, const PackedMatrix<Real>& M) {$/;"	f	namespace:kaldi
operator =	compressed-matrix.cc	/^CompressedMatrix &CompressedMatrix::operator = (const CompressedMatrix &mat) {$/;"	f	class:kaldi::CompressedMatrix
operator =	compressed-matrix.cc	/^CompressedMatrix &CompressedMatrix::operator =(const MatrixBase<Real> &mat) {$/;"	f	class:kaldi::CompressedMatrix
operator =	kaldi-matrix.h	/^  Matrix<Real> &operator = (const Matrix<Real> &other) {$/;"	f	class:kaldi::Matrix
operator =	kaldi-matrix.h	/^  Matrix<Real> &operator = (const MatrixBase<Real> &other) {$/;"	f	class:kaldi::Matrix
operator =	kaldi-vector.h	/^  SubVector & operator = (const SubVector &other) {}$/;"	f	class:kaldi::SubVector
operator =	kaldi-vector.h	/^  Vector<Real> &operator = (const Vector<Real> &other) {$/;"	f	class:kaldi::Vector
operator =	kaldi-vector.h	/^  Vector<Real> &operator = (const VectorBase<Real> &other) {$/;"	f	class:kaldi::Vector
operator =	packed-matrix.h	/^  PackedMatrix<Real> & operator =(const PackedMatrix<Real> &other) {$/;"	f	class:kaldi::PackedMatrix
operator >>	kaldi-matrix-inl.h	/^inline std::istream & operator >> (std::istream & is, Matrix<Real> & M) {$/;"	f	namespace:kaldi
operator >>	kaldi-matrix-inl.h	/^inline std::istream & operator >> (std::istream & is, MatrixBase<Real> & M) {$/;"	f	namespace:kaldi
operator >>	kaldi-vector-inl.h	/^std::istream &operator >> (std::istream &is, Vector<Real> &rv) {$/;"	f	namespace:kaldi
operator >>	kaldi-vector-inl.h	/^std::istream &operator >> (std::istream &is, VectorBase<Real> &rv) {$/;"	f	namespace:kaldi
operator >>	packed-matrix.h	/^std::istream & operator >> (std::istream &is, PackedMatrix<Real> &M) {$/;"	f	namespace:kaldi
optimize_delta	sp-matrix.h	/^  bool optimize_delta;$/;"	m	struct:kaldi::SolverOptions
opts_	optimization.h	/^  LbfgsOptions opts_;$/;"	m	class:kaldi::OptimizeLbfgs
ort_	jama-eig.h	/^  Real *ort_;  \/\/ working storage for nonsymmetric algorithm.$/;"	m	class:kaldi::EigenvalueDecomposition
percentile_0	compressed-matrix.h	/^    uint16 percentile_0;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
percentile_100	compressed-matrix.h	/^    uint16 percentile_100;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
percentile_25	compressed-matrix.h	/^    uint16 percentile_25;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
percentile_75	compressed-matrix.h	/^    uint16 percentile_75;$/;"	m	struct:kaldi::CompressedMatrix::PerColHeader
powers_	matrix-functions.h	/^  std::vector<Matrix<Real> > powers_;  \/\/ powers (>1) of P_ stored here,$/;"	m	class:kaldi::MatrixExponential
print_debug_output	sp-matrix.h	/^  bool print_debug_output;$/;"	m	struct:kaldi::SolverOptions
range	compressed-matrix.h	/^    float range;$/;"	m	struct:kaldi::CompressedMatrix::GlobalHeader
real	kaldi-blas.h	/^    typedef __CLPK_real             real;$/;"	t
rho_	optimization.h	/^  Vector<Real> rho_; \/\/ dimension m; rho_(m) = 1\/(y_m^T s_m), Eq. 7.17.$/;"	m	class:kaldi::OptimizeLbfgs
step_lengths_	optimization.h	/^  std::vector<Real> step_lengths_; \/\/ The step sizes we took on the last$/;"	m	class:kaldi::OptimizeLbfgs
stop_thresh	kaldi-gpsr.h	/^  double stop_thresh;  \/\/\/< Stopping threshold$/;"	m	struct:kaldi::GpsrConfig
stop_thresh_debias	kaldi-gpsr.h	/^  double stop_thresh_debias;  \/\/\/< Stopping threshold for debiasing stage$/;"	m	struct:kaldi::GpsrConfig
stride	kaldi-tensor.h	/^    int32 stride;$/;"	m	struct:kaldi::Tensor::DimInfo
stride0	kaldi-tensor.cc	/^  int32 stride0;  \/\/ stride of *this.$/;"	m	struct:kaldi::AddDimInfo	file:
stride1	kaldi-tensor.cc	/^  int32 stride1;  \/\/ stride of t1$/;"	m	struct:kaldi::AddDimInfo	file:
stride2	kaldi-tensor.cc	/^  int32 stride2;  \/\/ stride of t2.$/;"	m	struct:kaldi::AddDimInfo	file:
stride_	kaldi-matrix.h	/^  MatrixIndexT    stride_;$/;"	m	class:kaldi::MatrixBase
tab	srfft.h	/^  Real **tab;       \/\/ Tables of butterfly coefficients.$/;"	m	class:kaldi::SplitRadixComplexFft
tau_reduction	kaldi-gpsr.h	/^  double tau_reduction;  \/\/\/< Multiply tau by this if max_sparsity reached$/;"	m	struct:kaldi::GpsrConfig
temp_	optimization.h	/^  Vector<Real> temp_;$/;"	m	class:kaldi::OptimizeLbfgs
temp_buffer	srfft.h	/^  Real *temp_buffer;  \/\/ Allocated only if someone calls Compute with only$/;"	m	class:kaldi::SplitRadixComplexFft
use_gpsr_bb	kaldi-gpsr.h	/^  bool use_gpsr_bb;  \/\/\/< Use the Barzilai-Borwein gradient projection method$/;"	m	struct:kaldi::GpsrConfig
x_	optimization.h	/^  Vector<Real> x_; \/\/ current x.$/;"	m	class:kaldi::OptimizeLbfgs
~CompressedMatrix	compressed-matrix.h	/^  ~CompressedMatrix() { Destroy(); }$/;"	f	class:kaldi::CompressedMatrix
~EigenvalueDecomposition	jama-eig.h	/^EigenvalueDecomposition<Real>::~EigenvalueDecomposition() {$/;"	f	class:kaldi::EigenvalueDecomposition
~Matrix	kaldi-matrix.h	/^  ~Matrix() { Destroy(); }$/;"	f	class:kaldi::Matrix
~MatrixBase	kaldi-matrix.h	/^  ~MatrixBase() { }$/;"	f	class:kaldi::MatrixBase
~PackedMatrix	packed-matrix.h	/^  ~PackedMatrix() {$/;"	f	class:kaldi::PackedMatrix
~SplitRadixComplexFft	srfft.cc	/^SplitRadixComplexFft<Real>::~SplitRadixComplexFft() {$/;"	f	class:kaldi::SplitRadixComplexFft
~SubMatrix	kaldi-matrix.h	/^  ~SubMatrix<Real>() {}$/;"	f	class:kaldi::SubMatrix
~SubVector	kaldi-vector.h	/^  ~SubVector() {}  \/\/\/< Destructor (does nothing; no pointers are owned here).$/;"	f	class:kaldi::SubVector
~Vector	kaldi-vector.h	/^  ~Vector() { Destroy(); }$/;"	f	class:kaldi::Vector
~VectorBase	kaldi-vector.h	/^  ~VectorBase() {}$/;"	f	class:kaldi::VectorBase
